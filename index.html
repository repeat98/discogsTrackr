<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trackr</title>
    
    <!-- Favicon / App Icons -->
    <!-- Apple Touch Icon -->
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="img/apple-touch-icon.png"
    />
    <!-- Standard Favicon (ICO) -->
    <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />
    <!-- PNG Favicons for Different Sizes -->
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="img/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="img/favicon-16x16.png"
    />
    <!-- Web App Manifest -->
    <link rel="manifest" href="img/site.webmanifest" />
    
    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="Trackr">
    <meta property="og:description" content="Scan discogs sellers and discover what else they have available. Perfect for when you're ordering a record from a specific dealer - check out their other great releases and save on shipping costs.">
    <meta property="og:image" content="img/screen.jpg">
    <meta property="og:url" content="https://repeat98.github.io/discogsTrackr/">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Trackr">
    <meta name="twitter:description" content="Track discogs sellers - Track your favorite sellers">
    <meta name="twitter:image" content="img/screen.jpg">
    
    <!-- Google Analytics 4 (GA4) Global Site Tag -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-309VMDXR59"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "G-309VMDXR59");
    </script>
    <!-- End GA4 -->
    
    <!-- Google Fonts (Figtree) -->
    <link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    
    <!-- YouTube Iframe API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    
    <style>
/* -----------------------
   LIGHT THEME (DEFAULT)
------------------------- */
:root {
  --bg-color: #E0E0E0;
  --card-bg: #C9C9C9;
  --text-color: #1F1F1F;
  --border-color: #d5d7da;
  --primary-color: #C9C9C9;
  --table-header-bg: #C9C9C9;
  --table-header-text: #1F1F1F;
  --badge-genre-bg: #afafaf;
  --badge-genre-text: var(--text-color);
  --badge-style-bg: #c1c1c1;
  --badge-style-text: var(--text-color);
  --input-bg: #C9C9C9;
  --input-border: #d5d7da;
  --input-focus: #E7FF6E;
  --btn-primary-bg: #1a202c;
  --btn-primary-hover-bg: #2a2a2a;
  --transition-speed: 0.3s;
  --accent-color: #E7FF6E;
}

/* -----------------------
   DARK THEME
------------------------- */
body.dark-mode {
  --bg-color: #1F1F1F;
  --card-bg: #2D2D2D;
  --text-color: #ffffff;
  --border-color: #333;
  --primary-color: #2D2D2D;
  --table-header-bg: #3A3A3A;
  --table-header-text: #ffffff;
  --badge-genre-bg: #696969;
  --badge-genre-text: var(--text-color);
  --badge-style-bg: #3f3f3f;
  --badge-style-text: var(--text-color);
  --input-bg: #2D2D2D;
  --input-border: #555;
  --input-focus: #E7FF6E;
  --btn-primary-bg: #1a202c;
  --btn-primary-hover-bg: #2a2a2a;
}

/* -----------------------
   BASE STYLES
------------------------- */
html,
body {
  margin: 0;
  padding: 0;
  background-color: var(--bg-color);
  min-height: 100vh;
  height: 100%;
  overscroll-behavior: contain;
  font-family: "Figtree", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  color: var(--text-color);
  transition: background-color var(--transition-speed), color var(--transition-speed);
}

body::before {
  content: "";
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background: var(--bg-color);
  z-index: -999;
}

.Desktop {
  position: relative;
  min-height: 100vh;
  background: var(--bg-color);
}

.MainContainer {
  margin: 0 auto;
  max-width: 1500px;
  padding: 8px 16px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

/* -----------------------
   NAVBAR
------------------------- */
.navbar {
  background-color: var(--primary-color) !important;
  padding: 12px 0;
}

.navbar-brand {
  font-weight: bold;
  font-size: 18px;
  color: var(--text-color);
  display: flex;
  align-items: center;
  gap: 8px;
}

.powered-by {
  opacity: 0.8;
  font-size: 12px;
  font-style: italic;
  font-weight: 300;
}

/* Dark mode toggle */
.dark-mode-toggle {
  flex-shrink: 0;
  margin-left: 16px;
}

.dark-mode-toggle span {
  cursor: pointer;
  font-size: 1.25rem;
  color: var(--text-color);
}

.dark-mode-toggle .moon-icon {
  display: inline;
}

.dark-mode-toggle .sun-icon {
  display: none;
}

body.dark-mode .moon-icon {
  display: none;
}

body.dark-mode .sun-icon {
  display: inline;
}

/* Condition badge */
.badge-condition {
  background-color: var(--accent-color);
  color: #000;
  border-radius: 10px;
  font-size: 11px;
  line-height: 1;
  padding: 3px 6px;
  display: inline-block;
  z-index: 1;
}

.title-cell {
  position: relative;
  min-height: 22px;
  padding-right: 40px;
}

.title-cell .badge-condition {
  position: absolute;
  top: 4px;
  right: 4px;
}

/* Price badge placement */
.price-cell {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.price-cell .badge-condition {
  position: static;
}

.price-cell .price-text {
  font-weight: 600;
}

.title-cell .release-link {
  font-weight: 600;
}

/* Profile Icon */
.profile-icon {
  cursor: pointer;
  font-size: 1.25rem;
  color: var(--text-color);
  margin-left: 16px;
  transition: transform 0.3s;
}

.profile-icon:hover {
  transform: scale(1.1);
}

/* Settings Icon */
.settings-icon {
  cursor: pointer;
  font-size: 1.25rem;
  color: var(--text-color);
  margin-left: 16px;
  transition: transform 0.3s;
}

.settings-icon:hover {
  transform: rotate(45deg);
}

/* -----------------------
   SEARCH INPUT IN NAVBAR
------------------------- */
.search-input-wrapper {
  flex: 1;
  max-width: 400px;
  margin: 0 16px;
}

.search-input-wrapper input {
  width: 100%;
  background: var(--input-bg);
  border: 1px solid var(--input-border);
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  color: var(--text-color);
  transition: border-color var(--transition-speed);
}

.search-input-wrapper input::placeholder {
  color: var(--text-color);
  opacity: 0.5;
}

.search-input-wrapper input:focus {
  outline: none;
  border-color: var(--input-focus);
  box-shadow: 0 0 5px var(--input-focus);
}

/* -----------------------
   SELLERS SIDEBAR
------------------------- */
.sellers-sidebar {
  background: var(--card-bg);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

.sellers-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 12px;
}

.sellers-header .chips {
  display: none;
  flex-wrap: wrap;
  gap: 6px;
}

.sellers-sidebar.collapsed .seller-list {
  display: none;
}

.sellers-sidebar.collapsed .sellers-header .chips {
  display: flex;
}

.selected-chip {
  background: var(--table-header-bg);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  padding: 2px 8px;
  font-size: 12px;
}

.seller-list {
  list-style: none;
  padding: 0;
  margin: 0;
  max-height: 300px;
  overflow-y: auto;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.seller-item {
  padding: 8px 12px;
  background: var(--input-bg);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: opacity 0.2s;
  width: calc(50% - 4px);
}

@media (max-width: 768px) {
  .seller-item { width: 100%; }
}

.seller-item:hover {
  opacity: 0.8;
}

.seller-item.active {
  border: 2px solid var(--accent-color);
  background: var(--table-header-bg);
}

.seller-item.processing {
  border: 2px solid var(--accent-color);
}

.seller-info {
  flex: 1;
}

.seller-name {
  font-weight: 500;
  margin-bottom: 2px;
}

.seller-meta {
  font-size: 11px;
  opacity: 0.7;
}

.seller-actions {
  display: flex;
  gap: 4px;
}

.seller-actions button {
  padding: 2px 6px;
  font-size: 12px;
  background-color: var(--accent-color) !important;
  border-color: var(--accent-color) !important;
  color: #000 !important;
}

/* -----------------------
   SELLER PROGRESS
------------------------- */
.seller-progress {
  margin-top: 8px;
  width: 100%;
}

.seller-progress-bar {
  width: 100%;
  height: 6px;
  border-radius: 4px;
  background: var(--bg-color);
  overflow: hidden;
  position: relative;
}

.seller-progress-bar-fill {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background: var(--accent-color);
  transition: width 0.3s ease;
}

.seller-progress-text {
  font-size: 11px;
  margin-top: 4px;
  color: var(--text-color);
  opacity: 0.8;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}

/* -----------------------
   FILTER FORM
------------------------- */
.filter-form-wrapper {
  width: 100%;
  background: var(--card-bg);
  padding: 8px 0;
  margin-top: 8px;
}

.FilterContainer {
  border-radius: 0;
  overflow: hidden;
  display: flex;
  flex-direction: row;
  align-items: flex-end;
  gap: 8px;
  transition: background-color var(--transition-speed);
  flex-wrap: nowrap;
  overflow-x: auto;
}

.filter-group {
  position: relative;
  flex: 1;
  min-width: 120px;
  display: flex;
  flex-direction: column;
}

.filter-label {
  font-size: 12px;
  font-weight: 500;
  margin-bottom: 2px;
  color: var(--text-color);
}

.filter-input,
.filter-select {
  width: 100%;
  background: var(--input-bg);
  box-shadow: 0px 1px 2px rgba(10, 12, 18, 0.05);
  border: 1px solid var(--input-border);
  border-radius: 4px;
  font-size: 12px;
  color: var(--text-color);
  padding: 8px 10px;
  transition: border-color var(--transition-speed), box-shadow var(--transition-speed);
  min-height: 36px;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}

.filter-input::placeholder {
  color: var(--text-color);
  opacity: 0.5;
}

.filter-input:focus,
.filter-select:focus {
  outline: none;
  border-color: var(--input-focus);
  box-shadow: 0 0 5px var(--input-focus);
}

.filter-button-group {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
  margin-left: auto;
}

.filter-btn,
.shuffle-btn {
  background-color: var(--accent-color) !important;
  border-color: var(--accent-color) !important;
  color: #000 !important;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.3s;
  border: none;
}

.filter-btn:hover,
.shuffle-btn:hover {
  opacity: 0.8;
}

/* -----------------------
   PROGRESS SECTION
------------------------- */
.progress-section {
  background: var(--card-bg);
  padding: 20px;
  border-radius: 8px;
  margin-bottom: 16px;
  display: none;
}

.progress-section.active {
  display: block;
}

.progress-section h3 {
  margin: 0 0 12px 0;
  font-size: 16px;
  color: var(--text-color);
}

.progress-bar-container {
  background: var(--bg-color);
  border-radius: 10px;
  height: 30px;
  overflow: hidden;
  margin: 15px 0;
}

.progress-bar {
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  height: 100%;
  width: 0%;
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
  font-size: 14px;
}

.status-message {
  color: var(--text-color);
  opacity: 0.8;
  font-size: 14px;
  margin-top: 10px;
}

/* -----------------------
   TABLE STYLES
------------------------- */
.table-container {
  border-radius: 0;
  overflow: visible;
  background: var(--bg-color);
  transition: background-color var(--transition-speed);
}

.table-container table.table {
  border-collapse: separate !important;
  border-spacing: 0 8px !important;
  background: transparent !important;
  width: 100%;
}

.table-container thead tr th {
  background-color: var(--table-header-bg) !important;
  color: var(--table-header-text) !important;
  border: none;
  text-transform: uppercase;
  opacity: 0.85;
  font-weight: normal;
  font-size: 12px;
  padding: 12px 16px;
  cursor: pointer;
  position: relative;
  white-space: nowrap; /* keep headers on a single line */
}

body.dark-mode .table-container thead tr th {
  color: #cccccc !important;
}

.table-container tbody tr {
  background-color: var(--card-bg) !important;
  border: none;
  transition: background-color var(--transition-speed);
}

body.dark-mode .table-container tbody tr {
  background-color: #2D2D2D !important;
}

.table-container tbody tr td {
  background-color: transparent !important;
  vertical-align: middle;
  font-size: 12px;
  padding: 16px;
  border: none;
  color: var(--text-color);
}

.table-container tbody tr:hover {
  background-color: inherit !important;
}

/* -----------------------
   BADGES
------------------------- */
.badge-genre,
.badge-style {
  border-radius: 16px;
  padding: 2px 8px;
  font-size: 12px;
  display: inline-block;
  white-space: nowrap;
  margin: 4px 4px 0 0;
}

.badge-genre {
  background: var(--badge-genre-bg) !important;
  color: var(--badge-genre-text) !important;
}

.badge-style {
  background: var(--badge-style-bg) !important;
  color: var(--badge-style-text) !important;
}

/* -----------------------
   PAGINATION
------------------------- */
.pagination-container {
  width: 100%;
  text-align: center;
  margin-top: 1rem;
}

.pagination {
  display: inline-flex !important;
  flex-wrap: nowrap !important;
  gap: 8px;
  margin: 0;
  padding: 0;
  list-style: none;
}

.pagination .page-item {
  display: inline-block !important;
  margin: 0;
  padding: 0;
}

.pagination .page-link {
  border-radius: 0 !important;
  border: 1px solid var(--border-color) !important;
  background-color: var(--card-bg) !important;
  color: var(--text-color) !important;
  padding: 0.375rem 0.75rem;
  text-decoration: none;
  transition: background-color var(--transition-speed), color var(--transition-speed);
  width: auto;
  flex: 0 0 auto;
}

.pagination .page-item:not(.disabled) .page-link:hover {
  background-color: var(--table-header-bg) !important;
  color: var(--table-header-text) !important;
}

.page-item.active .page-link {
  background-color: var(--table-header-bg) !important;
  border-color: var(--table-header-bg) !important;
  color: var(--table-header-text) !important;
}

/* -----------------------
   STARS & RATINGS
------------------------- */
.table tbody tr td i.bi-star,
.table tbody tr td i.bi-star-fill,
.table tbody tr td i.bi-star-half {
  color: var(--accent-color) !important;
}

/* -----------------------
   LINKS
------------------------- */
a,
a:visited,
a:hover,
a:focus,
a:active,
.text-primary {
  color: var(--text-color) !important;
  text-decoration: none;
}

a:hover {
  opacity: 0.8;
}

/* -----------------------
   NO RESULTS
------------------------- */
.no-results {
  text-align: center;
  padding: 2rem 0;
  color: var(--text-color);
}

.no-results i {
  font-size: 2rem;
  margin-bottom: 1rem;
  display: block;
}

/* -----------------------
   LOADING SPINNER
------------------------- */
.spinner-border {
  color: var(--accent-color) !important;
}

/* -----------------------
   YOUTUBE IFRAME & PREVIEW
------------------------- */
.table-iframe {
  border-radius: 4px;
  width: 220px;
  height: 124px;
}

.youtube-preview {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.youtube-player-container {
  margin-top: 8px;
  border: 2px solid var(--border-color);
  border-radius: 4px;
  overflow: hidden;
}

.release-link {
  font-weight: 500;
  text-decoration: none !important;
  transition: opacity 0.2s;
}

.release-link:hover {
  opacity: 0.7;
}

.table-container tbody tr td:first-child {
  font-weight: 500;
  max-width: 300px;
}

.table-container {
  overflow-x: auto;
}

@media (max-width: 1200px) {
  .table-container {
    overflow-x: scroll;
  }
  
  .table-container table {
    min-width: 1500px;
  }
}

.video-links {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 120px;
}

.video-links .btn {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 200px;
  text-align: left;
}

.video-carousel {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.video-nav {
  width: 220px;
}

.video-counter {
  font-size: 0.75rem;
  color: var(--text-color);
  opacity: 0.8;
}

.sort-indicator {
  margin-left: 6px;
  font-size: 0.9em;
  display: inline-block; /* keep icon inline to avoid wrapping */
}

th[data-sort-key] {
  cursor: pointer;
  position: relative;
  user-select: none;
}

th[data-sort-key]:hover {
  opacity: 0.8;
  background-color: rgba(0, 0, 0, 0.05);
}

body.dark-mode th[data-sort-key]:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

#results-count {
  color: var(--text-color);
  font-size: 14px;
  font-weight: 600;
}

/* Heart button styling */
.wantlist-heart-btn {
  border: none !important;
  background: transparent !important;
  padding: 4px 8px;
  cursor: pointer;
}

.wantlist-heart-btn:hover {
  background: transparent !important;
  opacity: 0.7;
}

.wantlist-heart-btn:focus {
  box-shadow: none !important;
  outline: none !important;
}

/* User profile dropdown */
.user-profile-dropdown {
  position: relative;
  display: inline-block;
}

.user-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid var(--accent-color);
}

.user-dropdown-menu {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  margin-top: 8px;
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  min-width: 200px;
  z-index: 1000;
  padding: 8px 0;
}

.user-dropdown-menu.show {
  display: block;
}

.user-dropdown-item {
  padding: 10px 16px;
  cursor: pointer;
  color: var(--text-color);
  transition: background-color 0.2s;
}

.user-dropdown-item:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

body.dark-mode .user-dropdown-item:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

.user-dropdown-divider {
  height: 1px;
  background-color: var(--border-color);
  margin: 4px 0;
}

.oauth-login-btn {
  background-color: var(--btn-primary-bg);
  color: #ffffff;
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s;
}

.oauth-login-btn:hover {
  background-color: var(--btn-primary-hover-bg);
}

/* Modal styling */
.modal-content {
  background-color: var(--card-bg);
  color: var(--text-color);
}

.modal-header {
  border-bottom: 1px solid var(--border-color);
}

.modal-footer {
  border-top: 1px solid var(--border-color);
}

.form-control {
  background-color: var(--input-bg);
  color: var(--text-color);
  border: 1px solid var(--input-border);
}

.form-control:focus {
  background-color: var(--input-bg);
  color: var(--text-color);
  border-color: var(--input-focus);
  box-shadow: 0 0 5px var(--input-focus);
}

/* Improve readability inside modals and inputs */
body.dark-mode .form-control {
  color: #ffffff !important;
}
body.dark-mode .form-control::placeholder {
  color: #cfcfcf !important;
  opacity: 0.8 !important;
}

.form-label {
  color: var(--text-color);
}

.btn-close {
  filter: invert(1);
}

body.dark-mode .btn-close {
  filter: invert(0);
}

/* -----------------------
   MOBILE RESPONSIVENESS
------------------------- */
@media (max-width: 768px) {
  .FilterContainer {
    flex-direction: column;
    align-items: stretch;
  }

  .filter-button-group {
    margin-top: 10px;
    position: static;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    width: 100%;
  }

  .search-input-wrapper {
    max-width: 100%;
    margin: 8px 0;
  }

  .MainContainer {
    padding: 8px;
  }

  .navbar-brand {
    font-size: 16px;
  }

  .powered-by {
    display: none;
  }

  /* Hide table headers on mobile */
  .table-container thead {
    display: none;
  }

  /* Force table to take full width on mobile */
  .table-container table {
    width: 100%;
    display: block;
  }

  .table-container tbody {
    display: block;
    width: 100%;
  }

  .table-container tbody tr {
    display: block;
    width: 100%;
    margin-bottom: 16px;
  }

  /* Mobile cell styling */
  .table-container tbody tr td {
    display: block;
    width: 100% !important;
    padding: 12px;
  }

  .mobile-cell {
    display: block;
    width: 100%;
    box-sizing: border-box;
  }

  .mobile-preview {
    margin-bottom: 8px;
  }

  .mobile-preview iframe {
    width: 100%;
    height: auto;
    aspect-ratio: 16 / 9;
    max-width: 100%;
  }

  .mobile-title {
    margin-bottom: 8px;
    font-size: 16px;
    font-weight: bold;
    color: var(--text-color);
  }

  .mobile-rating {
    font-size: 14px;
  }

  /* Mobile filter toggle */
  .mobile-extra-filters-wrapper {
    display: none;
  }

  .mobile-toggle-btn {
    display: block;
    width: 40px;
    height: 40px;
    padding: 0;
    text-align: center;
    line-height: 40px;
    border-radius: 50%;
    margin-left: auto;
    background: transparent;
    border: none;
    color: var(--text-color);
    font-size: 1rem;
    cursor: pointer;
  }

  .mobile-toggle-btn i {
    transition: transform 0.3s;
  }

  .mobile-toggle-btn.open i {
    transform: rotate(180deg);
  }

  .mobile-extra-filters-wrapper.show {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .filter-input,
  .filter-select {
    font-size: 14px;
    padding: 10px 12px;
    min-height: 44px;
  }
}

/* Desktop: show all filters inline */
@media (min-width: 769px) {
  #mobile-filters-toggle {
    display: none;
  }

  .mobile-extra-filters-wrapper {
    display: inline-flex;
    flex-direction: row;
    gap: 8px;
  }
}

/* -----------------------
   FOOTER
------------------------- */
footer {
  margin-top: 2rem;
  padding: 1rem 0;
  color: var(--text-color);
  opacity: 0.7;
}

footer a {
  color: var(--text-color) !important;
  text-decoration: none;
}

footer a:hover {
  opacity: 0.8;
}
/* Improve muted text contrast on current backgrounds */
.text-muted {
  color: var(--text-color) !important;
  opacity: 0.7 !important;
}

/* Make form-text readable */
.form-text {
  color: var(--text-color) !important;
  opacity: 0.8 !important;
}

/* Brand style for Add Seller button (without changing HTML) */
.sellers-header .btn.btn-outline-primary,
.sellers-header .btn.btn-sm.btn-outline-primary {
  background-color: var(--accent-color) !important;
  border-color: var(--accent-color) !important;
  color: #000 !important;
}

.sellers-header .btn.btn-outline-primary:hover,
.sellers-header .btn.btn-sm.btn-outline-primary:hover {
  background-color: var(--accent-color) !important;
  border-color: var(--accent-color) !important;
  color: #000 !important;
  opacity: 0.9;
}
/* Brand utility styles */
.btn-brand {
  background-color: var(--accent-color) !important;
  border-color: var(--accent-color) !important;
  color: #000 !important;
}
.btn-brand:hover {
  background-color: var(--accent-color) !important;
  border-color: var(--accent-color) !important;
  color: #000 !important;
  opacity: 0.9;
}
.brand-link {
  color: var(--accent-color) !important;
  text-decoration: none !important;
  font-weight: 500;
}

.brand-link:hover {
  color: var(--accent-color) !important;
  text-decoration: underline !important;
  opacity: 0.9;
}

.text-muted .brand-link,
.text-muted small .brand-link {
  color: var(--accent-color) !important;
}
/* -----------------------
   SEARCH TO THE RIGHT (CSS-only)
------------------------- */
@media (min-width: 769px) {
  /* Push the search group to the far right without changing HTML */
  .FilterContainer .filter-group:has(> #text_search) {
    order: 99;
    margin-left: auto;
    max-width: 320px;
  }
}

/* (Removed CSS-grid column remap in favor of JS column order to avoid table header glitches) */
    </style>
</head>
<body class="dark-mode">
    <div class="Desktop">
        <!-- Navbar -->
        <nav class="navbar navbar-expand-lg navbar-dark">
            <div class="container MainContainer">
                <div class="d-flex justify-content-between align-items-center w-100">
                    <a class="navbar-brand d-flex align-items-center" href="./">
                        <img
                            src="img/gruuvs-logo.svg"
                            alt="Discogs Trackr Logo"
                            class="me-2"
                            style="height: 24px; width: auto"
                        />
                        TRACKR
                        <span class="powered-by d-none d-md-inline fst-italic fw-light ms-1">
                            Track discogs sellers
                        </span>
                    </a>
                    <div class="d-flex align-items-center">
                        <div class="search-input-wrapper me-2 d-none d-md-block" style="max-width: 260px; position: relative;">
                            <input type="text" id="navSearchInput" class="form-control form-control-sm" placeholder="Search..." style="padding-right: 28px;">
                            <i class="bi bi-search" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); opacity: 0.6;"></i>
                        </div>
                        <!-- Collection and Wantlist icons (only show when logged in) -->
                        <span id="collectionIcon" class="settings-icon" onclick="showUserCollection()" style="display: none;" title="My Collection">
                            <i class="bi bi-collection"></i>
                        </span>
                        <span id="wantlistIcon" class="settings-icon" onclick="showUserWantlist()" style="display: none;" title="My Wantlist">
                            <i class="bi bi-heart"></i>
                        </span>
                        <span class="profile-icon" onclick="openProfile()">
                            <i class="bi bi-person-circle"></i>
                        </span>
                        <span class="settings-icon" onclick="openSettings()">
                            <i class="bi bi-gear"></i>
                        </span>
                        <div class="dark-mode-toggle">
                            <span id="darkModeToggle">
                                <span class="moon-icon"><i class="bi bi-moon"></i></span>
                                <span class="sun-icon"><i class="bi bi-sun"></i></span>
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Filter form -->
        <div class="filter-form-wrapper" id="filter-wrapper">
            <div class="container MainContainer">
                <form id="filter-form" class="FilterContainer">
                    <div class="filter-group">
                        <label for="genre" class="filter-label">Genre</label>
                        <select id="genre" name="genre" class="filter-select">
                            <option value="">All Genres</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="style" class="filter-label">Style</label>
                        <select id="style" name="style" class="filter-select">
                            <option value="">All Styles</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="artist" class="filter-label">Artist</label>
                        <select id="artist" name="artist" class="filter-select">
                            <option value="">All Artists</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="label" class="filter-label">Label</label>
                        <select id="label" name="label" class="filter-select">
                            <option value="">All Labels</option>
                        </select>
                    </div>
                    <!-- Mobile extra filters toggle button (only visible on mobile) -->
                    <button
                        type="button"
                        id="mobile-filters-toggle"
                        class="btn btn-secondary mobile-toggle-btn"
                    >
                        <i class="bi bi-chevron-down"></i>
                    </button>
                    <!-- Extra filters wrapped (year, rating, count, price) -->
                    <div class="mobile-extra-filters-wrapper">
                        <div class="filter-group">
                            <label for="year_range" class="filter-label">Year range</label>
                            <input type="text" id="year_range" name="year_range" class="filter-input" placeholder="e.g. 2010-2015">
                        </div>
                        <div class="filter-group">
                            <label for="rating_range" class="filter-label">Rating range</label>
                            <input type="text" id="rating_range" name="rating_range" class="filter-input" placeholder="e.g. 3-5">
                        </div>
                        <div class="filter-group">
                            <label for="rating_count_range" class="filter-label">Rating Count</label>
                            <input type="text" id="rating_count_range" name="rating_count_range" class="filter-input" placeholder="e.g. 10-100">
                        </div>
                        <div class="filter-group">
                            <label for="price_range" class="filter-label">Price range</label>
                            <input type="text" id="price_range" name="price_range" class="filter-input" placeholder="e.g. 5-25">
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <!-- Tracked Sellers -->
        <div class="container MainContainer">
            <div class="sellers-sidebar" id="sellersPanel">
                <div class="sellers-header">
                    <h5 class="mb-0">
                        <span>Tracked Sellers (<span id="sellerCount">0</span>)</span>
                    </h5>
                    <div class="chips" id="selectedChips"></div>
                    <div class="d-flex align-items-center gap-2">
                        <button class="btn btn-sm btn-brand" onclick="openAddSellerModal()">
                            <i class="bi bi-plus-circle"></i> Add Seller
                        </button>
                        <button class="btn btn-sm btn-brand" onclick="updateAllSellers()">
                            <i class="bi bi-arrow-repeat"></i> Update All
                        </button>
                        <button class="btn btn-sm btn-outline-secondary" onclick="toggleSellersPanel()" id="toggleSellersBtn">
                            <i class="bi bi-chevron-up"></i>
                        </button>
                    </div>
                </div>
                <ul class="seller-list" id="sellerList">
                    <li class="text-muted text-center py-3">No sellers tracked yet. Add one above!</li>
                </ul>
            </div>
        </div>

        <!-- Main Content container for table and pagination -->
        <div class="container MainContainer" style="position: relative" id="resultsSection">
            <div class="d-flex justify-content-between align-items-center mb-2" style="margin-top: 1rem">
                <div id="results-count" class="fw-semibold"></div>
            </div>

            <div class="table-container">
                <table class="table table-hover table-bordered mb-0">
                    <thead id="table-header"></thead>
                    <tbody id="releases-table-body">
                        <tr><td class="no-results" colspan="15">
                            <p>Add a seller above to start tracking releases</p>
                        </td></tr>
                    </tbody>
                </table>
            </div>

            <div class="pagination-container">
                <ul class="pagination" id="pagination" style="display: none;"></ul>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div class="modal fade" id="profileModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Profile & Data Management</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-4">
                        <h6 class="mb-3">Discogs Personal Access Token</h6>
                        <p class="text-muted small mb-2">To access your Collection and Wantlist, enter your Personal Access Token from <a href="https://www.discogs.com/settings/developers" target="_blank">Discogs Developer Settings</a>.</p>
                        
                        <div id="tokenLoginSection" style="display: block;">
                            <input type="text" class="form-control mb-2" id="profileTokenInput" placeholder="Paste your token here">
                            <button type="button" class="btn btn-brand w-100 mb-2" onclick="loginWithTokenFromProfile()">
                                <i class="bi bi-box-arrow-in-right"></i> Login
                            </button>
                        </div>
                        
                        <div id="tokenLoggedInSection" style="display: none;">
                            <div class="alert alert-success mb-2">
                                <i class="bi bi-check-circle"></i> Logged in as <strong id="profileUsername"></strong>
                            </div>
                            <button type="button" class="btn btn-outline-danger w-100" onclick="logoutOAuth()">
                                <i class="bi bi-box-arrow-right"></i> Logout
                            </button>
                        </div>
                    </div>
                    
                    <hr>
                    
                    <div class="mb-4">
                        <h6 class="mb-3">Export Data</h6>
                        <p class="text-muted small mb-3">Download all your data including tracked sellers, releases, inventory, and settings as a JSON file.</p>
                        <button type="button" class="btn btn-brand w-100" onclick="exportData()">
                            <i class="bi bi-download"></i> Export All Data
                        </button>
                    </div>
                    
                    <hr>
                    
                    <div>
                        <h6 class="mb-3">Import Data</h6>
                        <p class="text-muted small mb-3">Import data from a previously exported JSON file. This will replace your current data.</p>
                        <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                        <button type="button" class="btn btn-brand w-100" onclick="document.getElementById('importFileInput').click()">
                            <i class="bi bi-upload"></i> Import Data
                        </button>
                        <div class="alert alert-warning small mt-3 mb-0" role="alert">
                            <i class="bi bi-exclamation-triangle"></i> <strong>Warning:</strong> Importing will replace all existing data. Make sure to export your current data first if you want to keep it.
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Discogs API Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted small">Create an application in the Discogs Developer settings, then copy the Consumer Key and Consumer Secret into the fields below. <a href="https://www.discogs.com/settings/developers" target="_blank" class="brand-link">Open Discogs Developer settings</a>.</p>
                    <div class="mb-3">
                        <label for="consumerKey" class="form-label">Consumer Key</label>
                        <input type="text" class="form-control" id="consumerKey" placeholder="Your consumer key">
                    </div>
                    <div class="mb-3">
                        <label for="consumerSecret" class="form-label">Consumer Secret</label>
                        <input type="text" class="form-control" id="consumerSecret" placeholder="Your consumer secret">
                    </div>
                    <div class="alert alert-warning small mb-0" role="alert">
                        <i class="bi bi-info-circle"></i> <strong>Note:</strong> Discogs limits non-owned inventories to 100 pages (max 10,000 items). Sellers with larger inventories will only show their first 10,000 items. This is a Discogs API restriction.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-brand" onclick="saveSettings()">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Seller Modal -->
    <div class="modal fade" id="addSellerModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Add Discogs Seller</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <label for="addSellerInput" class="form-label">Discogs Username</label>
                    <input type="text" class="form-control" id="addSellerInput" placeholder="e.g. vinylseller" onkeypress="if(event.key==='Enter') addSellerFromModal()">
                    <div class="form-text">We will fetch this seller's inventory and keep it cached locally.</div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-brand" onclick="addSellerFromModal()">Add Seller</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Collection Modal -->
    <div class="modal fade" id="collectionModal" tabindex="-1">
        <div class="modal-dialog modal-xl modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">My Collection</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="collectionContent">
                        <div class="text-center py-4">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Wantlist Modal -->
    <div class="modal fade" id="wantlistModal" tabindex="-1">
        <div class="modal-dialog modal-xl modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">My Wantlist</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="wantlistContent">
                        <div class="text-center py-4">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- OAuth Login Instructions Modal -->
    <div class="modal fade" id="oauthLoginModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Login with Discogs</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p>To access your Collection and Wantlist, you need a <strong>Personal Access Token</strong> from Discogs.</p>
                    
                    <h6 class="mt-3">How to get your token:</h6>
                    <ol>
                        <li>Go to <a href="https://www.discogs.com/settings/developers" target="_blank">Discogs Developer Settings</a></li>
                        <li>Click <strong>"Generate new token"</strong></li>
                        <li>Copy the token that appears</li>
                        <li>Paste it below</li>
                    </ol>
                    
                    <div class="alert alert-warning mt-3">
                        <i class="bi bi-exclamation-triangle"></i> Keep this token private! It gives access to your Discogs account.
                    </div>
                    
                    <label for="userTokenInput" class="form-label mt-3">Personal Access Token</label>
                    <input type="text" class="form-control" id="userTokenInput" placeholder="Paste your token here">
                    
                    <div class="form-text">This token will be stored securely in your browser and never sent to any server except Discogs.</div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-brand" onclick="loginWithToken()">Login</button>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center py-3">
        <small>
            <a href="discogs.html" style="color: inherit; text-decoration: none">
                &copy; 2025 - Discogs Seller Tracker
            </a>
            <br />
            <span style="opacity: 0.7; font-size: 0.85em;">
                This application uses Discogs' API but is not affiliated with, sponsored, or endorsed by Discogs. 
                Discogs is a registered trademark of Zink Media, LLC. 
                <a href="https://www.discogs.com" target="_blank" style="color: inherit; text-decoration: underline;">Data provided by Discogs</a>.
            </span>
            <br />
            <a
                href="imprint.html"
                style="color: inherit; text-decoration: none; opacity: 0.7"
            >
                Impressum
            </a>
            |
            <a
                href="privacy.html"
                style="color: inherit; text-decoration: none; opacity: 0.7"
            >
                Datenschutzerkl√§rung
            </a>
        </small>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
// ==================== GLOBAL STATE ====================
let allData = [];
let filteredData = [];
let totalRecords = 0;
let currentPage = 1;
const pageSize = 10;
let totalPages = 1;
let currentJobId = null;
let processingInterval = null;
let youtubeApiReady = false;
let youtubePlayerInstances = {};
let currentSort = { column: 'bayesian_score', direction: 'desc' };
let hasSearched = false;
let currentVideoIndex = {};
let trackedSellers = [];
let selectedSellers = []; // Empty = all sellers

// OAuth State
let oauthUser = null;
let userAccessToken = null;

// View State
let currentView = 'sellers'; // 'sellers', 'collection', 'wantlist'
let userWantlistIds = new Set(); // Cache of release IDs in user's wantlist
let cachedCollectionData = null; // Cache enriched collection data
let cachedWantlistData = null; // Cache enriched wantlist data
let lastCollectionIds = new Set(); // Track collection release IDs
let lastWantlistIds = new Set(); // Track wantlist release IDs

// IndexedDB configuration for larger cached payloads
const DB_NAME = 'discogsSellerTracker';
const DB_VERSION = 1;
const SELLER_STORE = 'sellers';
const SELLER_METADATA_KEY = 'tracked_seller_metadata';
let sellerDBPromise = null;

function getSellerDB() {
    if (!sellerDBPromise) {
        sellerDBPromise = new Promise((resolve, reject) => {
            if (!window.indexedDB) {
                reject(new Error('IndexedDB not supported in this browser.'));
                return;
            }

            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(SELLER_STORE)) {
                    db.createObjectStore(SELLER_STORE, { keyPath: 'username' });
                }
            };

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }
    return sellerDBPromise;
}

async function getSellerDataFromDB(username) {
    try {
        const db = await getSellerDB();
        return await new Promise((resolve, reject) => {
            const tx = db.transaction(SELLER_STORE, 'readonly');
            const store = tx.objectStore(SELLER_STORE);
            const request = store.get(username);

            request.onsuccess = () => resolve(request.result || null);
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Failed to read seller data from IndexedDB:', error);
        return null;
    }
}

async function saveSellerDataToDB(seller) {
    try {
        const db = await getSellerDB();
        const payload = {
            username: seller.username,
            inventory: seller.inventory || [],
            releases: seller.releases || []
        };

        await new Promise((resolve, reject) => {
            const tx = db.transaction(SELLER_STORE, 'readwrite');
            const store = tx.objectStore(SELLER_STORE);
            const request = store.put(payload);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Failed to save seller data to IndexedDB:', error);
    }
}

async function deleteSellerDataFromDB(username) {
    try {
        const db = await getSellerDB();
        await new Promise((resolve, reject) => {
            const tx = db.transaction(SELLER_STORE, 'readwrite');
            const store = tx.objectStore(SELLER_STORE);
            const request = store.delete(username);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Failed to delete seller data from IndexedDB:', error);
    }
}

// ==================== STORAGE MANAGEMENT ====================
function cleanupLocalStorage() {
    try {
        const keys = Object.keys(localStorage);
        const now = Date.now();
        const MAX_JOB_AGE = 24 * 60 * 60 * 1000; // 24 hours
        let cleaned = 0;
        
        keys.forEach(key => {
            if (key.startsWith('job_')) {
                try {
                    const job = JSON.parse(localStorage.getItem(key));
                    if (job.createdAt && (now - job.createdAt > MAX_JOB_AGE)) {
                        localStorage.removeItem(key);
                        cleaned++;
                    }
                } catch (e) {
                    // Invalid job data, remove it
                    localStorage.removeItem(key);
                    cleaned++;
                }
            }
        });
        
        if (cleaned > 0) {
            console.log(`Cleaned up ${cleaned} old job entries from localStorage`);
        }
    } catch (e) {
        console.error('Failed to clean up old jobs:', e);
    }
}

function aggressiveCleanupLocalStorage() {
    // Emergency cleanup: remove ALL job data
    try {
        const keys = Object.keys(localStorage);
        let cleaned = 0;
        keys.forEach(key => {
            if (key.startsWith('job_')) {
                localStorage.removeItem(key);
                cleaned++;
            }
        });
        console.log(`Emergency cleanup: removed ${cleaned} job entries`);
        return cleaned > 0;
    } catch (e) {
        console.error('Failed aggressive cleanup:', e);
        return false;
    }
}

// ==================== INITIALIZATION ====================
document.addEventListener('DOMContentLoaded', async () => {
    // Clean up old job data on startup to free localStorage space
    cleanupLocalStorage();
    
    // Load user auth state
    loadOAuthState();
    
    checkCredentials();
    
    // Dark mode toggle
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (localStorage.getItem('darkModeEnabled') === 'true' || !localStorage.getItem('darkModeEnabled')) {
        document.body.classList.add('dark-mode');
    } else {
        document.body.classList.remove('dark-mode');
    }
    
    darkModeToggle.addEventListener('click', () => {
        if (document.body.classList.contains('dark-mode')) {
            document.body.classList.remove('dark-mode');
            localStorage.setItem('darkModeEnabled', 'false');
        } else {
            document.body.classList.add('dark-mode');
            localStorage.setItem('darkModeEnabled', 'true');
        }
    });

    // Filter change handlers (search now only in navbar)
    document.getElementById('genre').addEventListener('change', applyFilters);
    document.getElementById('style').addEventListener('change', applyFilters);
    document.getElementById('artist').addEventListener('change', applyFilters);
    document.getElementById('label').addEventListener('change', applyFilters);
    document.getElementById('year_range').addEventListener('input', debounce(applyFilters, 500));
    document.getElementById('rating_range').addEventListener('input', debounce(applyFilters, 500));
    document.getElementById('rating_count_range').addEventListener('input', debounce(applyFilters, 500));
    const priceRangeEl = document.getElementById('price_range');
    if (priceRangeEl) priceRangeEl.addEventListener('input', debounce(applyFilters, 500));
    
    // Navbar search
    const navSearch = document.getElementById('navSearchInput');
    if (navSearch) {
        navSearch.addEventListener('input', debounce(() => {
            applyFilters();
        }, 250));
    }

    // Mobile filter toggle
    const mobileFiltersToggle = document.getElementById('mobile-filters-toggle');
    const mobileExtraFilters = document.querySelector('.mobile-extra-filters-wrapper');
    if (mobileFiltersToggle && mobileExtraFilters) {
        mobileFiltersToggle.addEventListener('click', () => {
            mobileFiltersToggle.classList.toggle('open');
            mobileExtraFilters.classList.toggle('show');
        });
    }

    // Load tracked sellers and display
    await loadTrackedSellers();
    checkForStoredJob();
});

function onYouTubeIframeAPIReady() {
    youtubeApiReady = true;
}

// ==================== CREDENTIALS MANAGEMENT ====================
function checkCredentials() {
    const consumerKey = localStorage.getItem('discogs_consumer_key');
    const consumerSecret = localStorage.getItem('discogs_consumer_secret');
    
    if (!consumerKey || !consumerSecret) {
        setTimeout(() => {
            const modal = new bootstrap.Modal(document.getElementById('settingsModal'));
            modal.show();
        }, 500);
    }
}

function openSettings() {
    const modal = new bootstrap.Modal(document.getElementById('settingsModal'));
    document.getElementById('consumerKey').value = localStorage.getItem('discogs_consumer_key') || '';
    document.getElementById('consumerSecret').value = localStorage.getItem('discogs_consumer_secret') || '';
    modal.show();
}

function saveSettings() {
    const consumerKey = document.getElementById('consumerKey').value.trim();
    const consumerSecret = document.getElementById('consumerSecret').value.trim();
    
    if (!consumerKey || !consumerSecret) {
        alert('Please enter both Consumer Key and Consumer Secret');
        return;
    }
    
    localStorage.setItem('discogs_consumer_key', consumerKey);
    localStorage.setItem('discogs_consumer_secret', consumerSecret);
    
    // Track API connection
    if (typeof gtag !== 'undefined') {
        gtag('event', 'api_connected', {
            event_category: 'Discogs API',
            event_label: 'User configured API credentials'
        });
    }
    
    const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
    modal.hide();
    
    alert('Settings saved successfully!');
}

// ==================== PROFILE & DATA MANAGEMENT ====================
function openProfile() {
    const modal = new bootstrap.Modal(document.getElementById('profileModal'));
    modal.show();
}

async function exportData() {
    try {
        // Get all seller data from IndexedDB
        const db = await getSellerDB();
        const sellersData = await new Promise((resolve, reject) => {
            const tx = db.transaction(SELLER_STORE, 'readonly');
            const store = tx.objectStore(SELLER_STORE);
            const request = store.getAll();
            
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
        });
        
        // Get seller metadata from localStorage
        const metadataStr = localStorage.getItem(SELLER_METADATA_KEY);
        const metadata = metadataStr ? JSON.parse(metadataStr) : [];
        
        // Get settings
        const settings = {
            consumerKey: localStorage.getItem('discogs_consumer_key') || '',
            consumerSecret: localStorage.getItem('discogs_consumer_secret') || '',
            darkModeEnabled: localStorage.getItem('darkModeEnabled') || 'false'
        };
        
        // Combine all data
        const dataToExport = {
            version: '1.0',
            exportDate: new Date().toISOString(),
            sellers: sellersData,
            metadata: metadata,
            settings: settings
        };
        
        // Create download
        const dataStr = JSON.stringify(dataToExport, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `discogs-trackr-backup-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        alert('Data exported successfully!');
    } catch (error) {
        console.error('Export failed:', error);
        alert('Failed to export data: ' + error.message);
    }
}

async function handleImportFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!confirm('This will replace all your current data. Are you sure you want to continue?')) {
        event.target.value = ''; // Reset file input
        return;
    }
    
    try {
        const text = await file.text();
        const importData = JSON.parse(text);
        
        // Validate import data structure
        if (!importData.version || !importData.sellers || !importData.metadata || !importData.settings) {
            throw new Error('Invalid backup file format');
        }
        
        // Import sellers data to IndexedDB
        const db = await getSellerDB();
        
        // First, clear existing data
        await new Promise((resolve, reject) => {
            const tx = db.transaction(SELLER_STORE, 'readwrite');
            const store = tx.objectStore(SELLER_STORE);
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
            tx.onerror = () => reject(tx.error);
        });
        
        // Then, add imported sellers
        if (importData.sellers && importData.sellers.length > 0) {
            await new Promise((resolve, reject) => {
                const tx = db.transaction(SELLER_STORE, 'readwrite');
                const store = tx.objectStore(SELLER_STORE);
                
                const promises = importData.sellers.map(seller => {
                    return new Promise((resolveItem, rejectItem) => {
                        const request = store.put({
                            username: seller.username,
                            inventory: seller.inventory || [],
                            releases: seller.releases || []
                        });
                        request.onsuccess = () => resolveItem();
                        request.onerror = () => rejectItem(request.error);
                    });
                });
                
                Promise.all(promises).then(() => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                }).catch(reject);
            });
        }
        
        // Import metadata to localStorage
        if (importData.metadata && Array.isArray(importData.metadata)) {
            localStorage.setItem(SELLER_METADATA_KEY, JSON.stringify(importData.metadata));
        }
        
        // Import settings
        if (importData.settings) {
            if (importData.settings.consumerKey) {
                localStorage.setItem('discogs_consumer_key', importData.settings.consumerKey);
            }
            if (importData.settings.consumerSecret) {
                localStorage.setItem('discogs_consumer_secret', importData.settings.consumerSecret);
            }
            if (importData.settings.darkModeEnabled !== undefined) {
                localStorage.setItem('darkModeEnabled', importData.settings.darkModeEnabled);
                // Apply dark mode if needed
                if (importData.settings.darkModeEnabled === 'true') {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }
            }
        }
        
        // Reload tracked sellers
        await loadTrackedSellers();
        
        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('profileModal'));
        modal.hide();
        
        // Reset file input
        event.target.value = '';
        
        alert('Data imported successfully! Your page will refresh to show the imported data.');
        // Optionally reload the page to ensure everything is synced
        window.location.reload();
    } catch (error) {
        console.error('Import failed:', error);
        alert('Failed to import data: ' + error.message);
        event.target.value = ''; // Reset file input
    }
}

// ==================== SELLER MANAGEMENT ====================
async function loadTrackedSellers() {
    try {
        let metadata = [];
        const metadataStr = localStorage.getItem(SELLER_METADATA_KEY);

        if (metadataStr) {
            metadata = JSON.parse(metadataStr);
        } else {
            // Migration path from legacy localStorage structure
            const legacyStr = localStorage.getItem('tracked_sellers');
            if (legacyStr) {
                try {
                    const legacyData = JSON.parse(legacyStr);
                    if (Array.isArray(legacyData)) {
                        trackedSellers = legacyData.map(item => ({
                            username: item.username,
                            addedAt: item.addedAt || Date.now(),
                            lastUpdated: item.lastUpdated || null,
                            releases: item.releases || [],
                            inventory: item.inventory || [],
                            currentJob: null
                        }));

                        metadata = trackedSellers.map(({ username, addedAt, lastUpdated }) => ({
                            username,
                            addedAt,
                            lastUpdated
                        }));

                        await Promise.all(trackedSellers.map(seller => saveSellerDataToDB(seller)));
                        localStorage.removeItem('tracked_sellers');
                        localStorage.setItem(SELLER_METADATA_KEY, JSON.stringify(metadata));
                    }
                } catch (error) {
                    console.error('Failed to migrate legacy seller data:', error);
                }
            }
        }

        if (!metadata || !Array.isArray(metadata)) {
            metadata = [];
        }

        const sellersWithData = await Promise.all(metadata.map(async meta => {
            const stored = await getSellerDataFromDB(meta.username);
            return {
                username: meta.username,
                addedAt: meta.addedAt || Date.now(),
                lastUpdated: meta.lastUpdated || null,
                releases: stored?.releases || [],
                inventory: stored?.inventory || [],
                currentJob: null
            };
        }));

        trackedSellers = sellersWithData;
    } catch (error) {
        console.error('Failed to load tracked sellers:', error);
        trackedSellers = [];
    }

    updateSellerList();
    loadAllSellersData();
}

function saveTrackedSellers() {
    const metadata = trackedSellers.map(({ username, addedAt, lastUpdated }) => ({
        username,
        addedAt,
        lastUpdated
    }));

    try {
        localStorage.setItem(SELLER_METADATA_KEY, JSON.stringify(metadata));
        localStorage.removeItem('tracked_sellers');
    } catch (error) {
        console.error('Failed to persist seller metadata:', error);
    }
}

function updateSellerList() {
    const sellerList = document.getElementById('sellerList');
    const sellerCount = document.getElementById('sellerCount');
    const chips = document.getElementById('selectedChips');
    
    sellerCount.textContent = trackedSellers.length;
    chips.innerHTML = '';
    
    const chipsToShow = selectedSellers.length > 0 ? selectedSellers : trackedSellers.map(s => s.username);
    chipsToShow.forEach(name => {
        const span = document.createElement('span');
        span.className = 'selected-chip';
        span.textContent = name;
        chips.appendChild(span);
    });
    
    if (trackedSellers.length === 0) {
        sellerList.innerHTML = '<li class="text-muted text-center py-3">No sellers tracked yet. Add one above!</li>';
        return;
    }
    
    sellerList.innerHTML = '';
    trackedSellers.forEach(seller => {
        const li = document.createElement('li');
        li.className = 'seller-item';
        if (selectedSellers.length === 0 || selectedSellers.includes(seller.username)) {
            li.classList.add('active');
        }
        
        const releaseCount = seller.releases ? seller.releases.length : 0;
        const lastUpdated = seller.lastUpdated ? new Date(seller.lastUpdated).toLocaleDateString() : 'Never';
        const job = seller.currentJob;
        
        let jobMarkup = '';
        let cancelBtn = '';
        
        if (job && job.status === 'processing') {
            li.classList.add('processing');
            const percent = job.total > 0 ? Math.round((job.progress / job.total) * 100) : 0;
            const clampedPercent = Math.min(100, Math.max(0, percent));
            const safeStep = escapeHtml(job.currentStep || 'Processing...');
            const countLabel = job.total > 0 ? `${job.progress}/${job.total}` : '';
            const percentLabel = job.total > 0 ? `${percent}%` : '';
            const trailingLabel = percentLabel && countLabel ? `${percentLabel} ‚Ä¢ ${countLabel}` : (percentLabel || countLabel);
            
            jobMarkup = `
                <div class="seller-progress">
                    <div class="seller-progress-bar">
                        <div class="seller-progress-bar-fill" style="width: ${clampedPercent}%"></div>
                    </div>
                    <div class="seller-progress-text">
                        <span>${safeStep}</span>
                        <span>${trailingLabel || ''}</span>
                    </div>
                </div>
            `;
            
            if (job.jobId) {
                cancelBtn = `<button class="btn btn-sm btn-outline-warning" onclick="cancelJob('${job.jobId}', event)" title="Cancel">
                    <i class="bi bi-x-circle"></i>
                </button>`;
            }
        }
        
        li.innerHTML = `
            <div class="seller-info" onclick="toggleSeller('${seller.username}')">
                <div class="seller-name">${seller.username}</div>
                <div class="seller-meta">${releaseCount} releases ‚Ä¢ Updated: ${lastUpdated}</div>
                ${jobMarkup}
            </div>
            <div class="seller-actions">
                <button class="btn btn-sm btn-outline-primary" onclick="refreshSeller('${seller.username}', event)" title="Refresh">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
                ${cancelBtn}
                <button class="btn btn-sm btn-outline-danger" onclick="removeSeller('${seller.username}', event)" title="Remove">
                    <i class="bi bi-trash"></i>
                </button>
            </div>
        `;
        sellerList.appendChild(li);
    });
}

function toggleSeller(username) {
    const index = selectedSellers.indexOf(username);
    if (index === -1) {
        // If nothing selected, select this one
        if (selectedSellers.length === 0) {
            selectedSellers = [username];
        } else {
            selectedSellers.push(username);
        }
    } else {
        selectedSellers.splice(index, 1);
    }
    
    updateSellerList();
    loadAllSellersData();
}

function openAddSellerModal() {
    const modal = new bootstrap.Modal(document.getElementById('addSellerModal'));
    document.getElementById('addSellerInput').value = '';
    modal.show();
}

function toggleSellersPanel() {
    const panel = document.getElementById('sellersPanel');
    const btn = document.getElementById('toggleSellersBtn');
    panel.classList.toggle('collapsed');
    if (panel.classList.contains('collapsed')) {
        btn.innerHTML = '<i class="bi bi-chevron-down"></i>';
    } else {
        btn.innerHTML = '<i class="bi bi-chevron-up"></i>';
    }
}

async function addSellerFromModal() {
    const sellerInput = document.getElementById('addSellerInput');
    const username = sellerInput.value.trim();
    
    if (!username) {
        alert('Please enter a seller username');
        return;
    }
    
    const modal = bootstrap.Modal.getInstance(document.getElementById('addSellerModal'));
    if (modal) {
        modal.hide();
    }
    
    await addSeller(username);
}

async function addSeller(username) {
    
    if (!username) {
        alert('Please enter a seller username');
        return;
    }
    
    const consumerKey = localStorage.getItem('discogs_consumer_key');
    const consumerSecret = localStorage.getItem('discogs_consumer_secret');
    
    if (!consumerKey || !consumerSecret) {
        alert('Please configure your Discogs API credentials in Settings');
        openSettings();
        return;
    }
    
    // Check if already tracked
    if (trackedSellers.find(s => s.username === username)) {
        alert('This seller is already being tracked');
        return;
    }
    
    // Add seller
    const newSeller = {
        username,
        addedAt: Date.now(),
        lastUpdated: null,
        releases: [],
        inventory: [],
        currentJob: null
    };
    
    trackedSellers.push(newSeller);
    saveTrackedSellers();
    await saveSellerDataToDB(newSeller);
    updateSellerList();
    
    // Track seller scan
    if (typeof gtag !== 'undefined') {
        gtag('event', 'seller_scan', {
            event_category: 'Seller Tracking',
            event_label: username
        });
    }
    
    // Start fetching and processing automatically
    await fetchAndProcessSeller(username);
}

async function removeSeller(username, event) {
    event.stopPropagation();
    
    if (!confirm(`Remove ${username} from tracked sellers?`)) return;
    
    trackedSellers = trackedSellers.filter(s => s.username !== username);
    selectedSellers = selectedSellers.filter(u => u !== username);
    
    await deleteSellerDataFromDB(username);
    saveTrackedSellers();
    updateSellerList();
    loadAllSellersData();
}

async function refreshSeller(username, event) {
    event.stopPropagation();
    
    const seller = trackedSellers.find(s => s.username === username);
    if (!seller) return;
    
    // Track seller refresh
    if (typeof gtag !== 'undefined') {
        gtag('event', 'seller_scan', {
            event_category: 'Seller Tracking',
            event_label: `Refresh: ${username}`
        });
    }
    
    // Smart update: fetch inventory, compare, remove old releases, process only new ones
    await updateSellerWithDiff(username);
}

async function updateAllSellers() {
    if (!trackedSellers || trackedSellers.length === 0) {
        alert('No sellers to update. Add a seller first.');
        return;
    }
    if (!confirm('Update all sellers now? This will fetch latest inventories and update added/sold releases.')) {
        return;
    }
    
    // Track bulk update
    if (typeof gtag !== 'undefined') {
        gtag('event', 'seller_scan', {
            event_category: 'Seller Tracking',
            event_label: `Update All (${trackedSellers.length} sellers)`
        });
    }
    
    // Process sequentially to respect Discogs rate limits
    for (const seller of trackedSellers) {
        try {
            await updateSellerWithDiff(seller.username);
        } catch (e) {
            console.error('Failed to update seller', seller.username, e);
        }
    }
}

// Fetch inventory and automatically process all releases (for new sellers)
async function fetchAndProcessSeller(username) {
    const seller = trackedSellers.find(s => s.username === username);
    if (!seller) return;
    
    const jobId = 'job_' + Date.now();
    currentJobId = jobId;
    
    try {
        localStorage.setItem('currentJobId', jobId);
        localStorage.setItem('currentUsername', username);
    } catch (e) {
        console.warn('Could not store job metadata in localStorage:', e);
    }
    
    const job = createJob(jobId, username);
    seller.currentJob = job;
    updateSellerList();
    
    try {
        // Step 1: Fetch inventory
        let allListings = [];
        updateJob(jobId, { currentStep: 'Fetching inventory...' });
        updateProgress(jobId);
        
        let page = 1;
        const perPage = 100;
        let consecutive403s = 0;
        
        while (true) {
            try {
                const inventory = await getSellerInventory(username, page, perPage);
                const listings = inventory.listings || [];
                
                consecutive403s = 0;
                
                if (listings.length === 0) break;
                
                allListings.push(...listings);
                
                const totalPages = inventory.pagination?.pages || 1;
                updateJob(jobId, {
                    currentStep: `Fetching inventory: Page ${page} of ${totalPages}`,
                    progress: page,
                    total: totalPages
                });
                updateProgress(jobId);
                
                if (page >= totalPages) break;
                page++;
            } catch (error) {
                console.error(`Error fetching inventory page ${page}:`, error);
                if (error.message.includes('Forbidden (403)')) {
                    if (page >= 100) {
                        console.log(`‚úì Reached Discogs pagination limit at page ${page}. Successfully fetched ${allListings.length} items.`);
                        break;
                    }
                    
                    consecutive403s++;
                    if (consecutive403s >= 3) {
                        updateJob(jobId, { 
                            status: 'error', 
                            currentStep: 'Discogs API error 403: Rate limit exceeded.' 
                        });
                        updateProgress(jobId);
                        finishJob(jobId, username);
                        return;
                    }
                    const waitTime = 60000 * Math.pow(2, consecutive403s - 1);
                    updateJob(jobId, { 
                        currentStep: `Rate limited (403), waiting ${waitTime / 1000}s before retry...` 
                    });
                    updateProgress(jobId);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    continue;
                }
                if (error.message.includes('Rate limited')) {
                    updateJob(jobId, { currentStep: 'Rate limited (429), waiting 60s...' });
                    updateProgress(jobId);
                    await new Promise(resolve => setTimeout(resolve, 60000));
                    continue;
                }
                if (allListings.length > 0) break;
                throw error;
            }
        }
        
        if (allListings.length === 0) {
            updateJob(jobId, {
                status: 'error',
                currentStep: 'No listings found for this seller'
            });
            updateProgress(jobId);
            finishJob(jobId, username);
            return;
        }
        
        // Save inventory
        seller.inventory = allListings;
        await saveSellerDataToDB(seller);
        
        // Step 2: Automatically process all releases
        updateJob(jobId, { currentStep: 'Processing releases...' });
        updateProgress(jobId);
        
        await processAllReleasesFromInventory(jobId, username, allListings);
        
    } catch (error) {
        console.error('Error in fetchAndProcessSeller:', error);
        updateJob(jobId, {
            status: 'error',
            currentStep: `Error: ${error.message}`
        });
        updateProgress(jobId);
        finishJob(jobId, username);
    }
}

// Update seller with smart diff: fetch inventory, compare, remove old, process only new
async function updateSellerWithDiff(username) {
    const seller = trackedSellers.find(s => s.username === username);
    if (!seller) return;
    
    const jobId = 'job_' + Date.now();
    currentJobId = jobId;
    
    try {
        localStorage.setItem('currentJobId', jobId);
        localStorage.setItem('currentUsername', username);
    } catch (e) {
        console.warn('Could not store job metadata in localStorage:', e);
    }
    
    const job = createJob(jobId, username);
    seller.currentJob = job;
    updateSellerList();
    
    try {
        // Step 1: Fetch current inventory
        let allListings = [];
        updateJob(jobId, { currentStep: 'Fetching inventory...' });
        updateProgress(jobId);
        
        let page = 1;
        const perPage = 100;
        let consecutive403s = 0;
        
        while (true) {
            try {
                const inventory = await getSellerInventory(username, page, perPage);
                const listings = inventory.listings || [];
                
                consecutive403s = 0;
                
                if (listings.length === 0) break;
                
                allListings.push(...listings);
                
                const totalPages = inventory.pagination?.pages || 1;
                updateJob(jobId, {
                    currentStep: `Fetching inventory: Page ${page} of ${totalPages}`,
                    progress: page,
                    total: totalPages
                });
                updateProgress(jobId);
                
                if (page >= totalPages) break;
                page++;
            } catch (error) {
                console.error(`Error fetching inventory page ${page}:`, error);
                if (error.message.includes('Forbidden (403)')) {
                    if (page >= 100) {
                        console.log(`‚úì Reached Discogs pagination limit at page ${page}.`);
                        break;
                    }
                    
                    consecutive403s++;
                    if (consecutive403s >= 3) {
                        updateJob(jobId, { 
                            status: 'error', 
                            currentStep: 'Discogs API error 403: Rate limit exceeded.' 
                        });
                        updateProgress(jobId);
                        finishJob(jobId, username);
                        return;
                    }
                    const waitTime = 60000 * Math.pow(2, consecutive403s - 1);
                    updateJob(jobId, { 
                        currentStep: `Rate limited (403), waiting ${waitTime / 1000}s...` 
                    });
                    updateProgress(jobId);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    continue;
                }
                if (error.message.includes('Rate limited')) {
                    updateJob(jobId, { currentStep: 'Rate limited (429), waiting 60s...' });
                    updateProgress(jobId);
                    await new Promise(resolve => setTimeout(resolve, 60000));
                    continue;
                }
                if (allListings.length > 0) break;
                throw error;
            }
        }
        
        if (allListings.length === 0) {
            updateJob(jobId, {
                status: 'error',
                currentStep: 'No listings found for this seller'
            });
            updateProgress(jobId);
            finishJob(jobId, username);
            return;
        }
        
        // Step 2: Compare with existing releases
        updateJob(jobId, { currentStep: 'Comparing inventory...' });
        updateProgress(jobId);
        
        const uniqueReleases = {};
        for (const listing of allListings) {
            const release = listing.release;
            if (!release || !release.id) continue;
            
            const price = parseFloat(listing.price?.value || 0);
            const cond = listing.condition || listing.media_condition || listing.item_condition || listing.condition_grade || '';
            if (!uniqueReleases[release.id] || (price > 0 && price < uniqueReleases[release.id].price)) {
                uniqueReleases[release.id] = {
                    id: release.id,
                    artist: release.artist || 'Unknown Artist',
                    title: release.title || 'Unknown Title',
                    price: price,
                    condition: cond
                };
            }
        }
        
        const currentReleaseIds = Object.keys(uniqueReleases).map(id => parseInt(id));
        const existingReleases = seller.releases || [];
        const existingIds = new Set(existingReleases.map(r => r.id));
        
        // Find releases to remove (no longer in inventory)
        const removedIds = existingReleases.filter(r => !currentReleaseIds.includes(r.id)).map(r => r.id);
        
        // Find new releases to process
        const newReleaseIds = currentReleaseIds.filter(id => !existingIds.has(id));
        
        // Step 3: Remove releases no longer in inventory
        if (removedIds.length > 0) {
            seller.releases = existingReleases.filter(r => !removedIds.includes(r.id));
            console.log(`Removed ${removedIds.length} releases no longer in inventory`);
            await saveSellerDataToDB(seller);
            loadAllSellersData();
        }
        
        // Update inventory
        seller.inventory = allListings;
        await saveSellerDataToDB(seller);
        
        // Step 4: Process only new releases
        if (newReleaseIds.length === 0) {
            updateJob(jobId, {
                status: 'complete',
                currentStep: `All up to date! (${removedIds.length} removed)`,
                progress: 1,
                total: 1
            });
            updateProgress(jobId);
            
            seller.lastUpdated = Date.now();
            saveTrackedSellers();
            finishJob(jobId, username);
            return;
        }
        
        updateJob(jobId, {
            currentStep: `Processing ${newReleaseIds.length} new releases...`,
            progress: 0,
            total: newReleaseIds.length
        });
        updateProgress(jobId);
        
        // Process new releases
        await processNewReleases(jobId, username, newReleaseIds, uniqueReleases);
        
    } catch (error) {
        console.error('Error in updateSellerWithDiff:', error);
        updateJob(jobId, {
            status: 'error',
            currentStep: `Error: ${error.message}`
        });
        updateProgress(jobId);
        finishJob(jobId, username);
    }
}

// Process all releases from inventory (for new sellers)
async function processAllReleasesFromInventory(jobId, username, allListings) {
    const seller = trackedSellers.find(s => s.username === username);
    if (!seller) return;
    
    // Extract unique releases
    const uniqueReleases = {};
    for (const listing of allListings) {
        const release = listing.release;
        if (!release || !release.id) continue;
        
        const price = parseFloat(listing.price?.value || 0);
        const cond = listing.condition || listing.media_condition || listing.item_condition || listing.condition_grade || '';
        if (!uniqueReleases[release.id] || (price > 0 && price < uniqueReleases[release.id].price)) {
            uniqueReleases[release.id] = {
                id: release.id,
                artist: release.artist || 'Unknown Artist',
                title: release.title || 'Unknown Title',
                price: price,
                condition: cond
            };
        }
    }
    
    const releaseIds = Object.keys(uniqueReleases);
    
    updateJob(jobId, {
        total: releaseIds.length,
        progress: 0,
        currentStep: `Processing ${releaseIds.length} releases...`
    });
    updateProgress(jobId);
    
    const processedReleases = [];
    let consecutiveErrors = 0;
    
    for (let i = 0; i < releaseIds.length; i++) {
        const job = getJobFromStorage(jobId);
        if (job && job.status === 'cancelled') {
            console.log('Job cancelled');
            return;
        }
        
        const releaseId = releaseIds[i];
        const basicInfo = uniqueReleases[releaseId];
        
        try {
            const details = await getReleaseDetails(releaseId);
            
            const ratingData = details.community?.rating || {};
            const avgRating = parseFloat(ratingData.average || 0);
            const numRatings = parseInt(ratingData.count || 0);
            const bayesianScore = bayesianRating(avgRating, numRatings);
            
            const haveCount = parseInt(details.community?.have || 0);
            const wantCount = parseInt(details.community?.want || 0);
            
            const releaseData = {
                id: parseInt(releaseId),
                artist_title: `${basicInfo.artist} - ${basicInfo.title}`,
                artist: details.artists?.[0]?.name || basicInfo.artist,
                title: details.title || basicInfo.title,
                label: details.labels?.[0]?.name || null,
                year: details.year || null,
                genres: JSON.stringify(details.genres || []),
                styles: JSON.stringify(details.styles || []),
                avg_rating: avgRating,
                num_ratings: numRatings,
                bayesian_score: bayesianScore,
                price: basicInfo.price,
                condition: basicInfo.condition || '',
                have_count: haveCount,
                want_count: wantCount,
                youtube_video_id: null,
                video_urls: JSON.stringify(details.videos || []),
                url: `https://www.discogs.com/release/${releaseId}`,
                demand_coeff: computeRarityCoeff(haveCount, wantCount)
            };
            
            processedReleases.push(releaseData);
            
            updateJob(jobId, {
                progress: i + 1,
                currentStep: `Processing: ${i + 1} of ${releaseIds.length} releases`
            });
            updateProgress(jobId);
            
            seller.releases = processedReleases;
            
            if ((i + 1) % 10 === 0 || i === releaseIds.length - 1) {
                await saveSellerDataToDB(seller);
                loadAllSellersData();
            }
            
            consecutiveErrors = 0;
            
        } catch (error) {
            console.error(`Error fetching details for release ${releaseId}:`, error);
            
            if (error.message.includes('Forbidden (403)')) {
                consecutiveErrors++;
                
                seller.releases = processedReleases;
                await saveSellerDataToDB(seller);
                loadAllSellersData();
                
                if (consecutiveErrors >= 3) {
                    updateJob(jobId, { 
                        status: 'complete', 
                        currentStep: `Processed ${processedReleases.length}/${releaseIds.length} releases (rate limited)` 
                    });
                    updateProgress(jobId);
                    seller.lastUpdated = Date.now();
                    saveTrackedSellers();
                    finishJob(jobId, username);
                    return;
                }
                
                const waitMinutes = consecutiveErrors * 2;
                const waitMs = waitMinutes * 60 * 1000;
                
                updateJob(jobId, { 
                    currentStep: `Rate limited (403), waiting ${waitMinutes}min... (${i + 1}/${releaseIds.length})` 
                });
                updateProgress(jobId);
                await new Promise(resolve => setTimeout(resolve, waitMs));
                i--;
                continue;
            }
            
            if (error.message.includes('Rate limited')) {
                consecutiveErrors++;
                updateJob(jobId, { currentStep: `Rate limited (429), waiting 60s... (${i + 1}/${releaseIds.length})` });
                updateProgress(jobId);
                await new Promise(resolve => setTimeout(resolve, 60000));
                i--;
                continue;
            }
            
            console.warn(`Skipping release ${releaseId} due to error:`, error.message);
        }
    }
    
    seller.lastUpdated = Date.now();
    saveTrackedSellers();
    await saveSellerDataToDB(seller);
    updateSellerList();
    
    updateJob(jobId, {
        status: 'complete',
        currentStep: `Complete! Processed ${processedReleases.length} releases.`,
        progress: releaseIds.length
    });
    updateProgress(jobId);
    
    loadAllSellersData();
    finishJob(jobId, username);
}

// Process only new releases (for updates)
async function processNewReleases(jobId, username, newReleaseIds, uniqueReleases) {
    const seller = trackedSellers.find(s => s.username === username);
    if (!seller) return;
    
    const existingReleases = seller.releases || [];
    const processedReleases = [...existingReleases];
    let consecutiveErrors = 0;
    
    for (let i = 0; i < newReleaseIds.length; i++) {
        const job = getJobFromStorage(jobId);
        if (job && job.status === 'cancelled') {
            console.log('Job cancelled');
            return;
        }
        
        const releaseId = newReleaseIds[i];
        const basicInfo = uniqueReleases[releaseId];
        
        try {
            const details = await getReleaseDetails(releaseId);
            
            const ratingData = details.community?.rating || {};
            const avgRating = parseFloat(ratingData.average || 0);
            const numRatings = parseInt(ratingData.count || 0);
            const bayesianScore = bayesianRating(avgRating, numRatings);
            
            const haveCount = parseInt(details.community?.have || 0);
            const wantCount = parseInt(details.community?.want || 0);
            
            const releaseData = {
                id: parseInt(releaseId),
                artist_title: `${basicInfo.artist} - ${basicInfo.title}`,
                artist: details.artists?.[0]?.name || basicInfo.artist,
                title: details.title || basicInfo.title,
                label: details.labels?.[0]?.name || null,
                year: details.year || null,
                genres: JSON.stringify(details.genres || []),
                styles: JSON.stringify(details.styles || []),
                avg_rating: avgRating,
                num_ratings: numRatings,
                bayesian_score: bayesianScore,
                price: basicInfo.price,
                condition: basicInfo.condition || '',
                have_count: haveCount,
                want_count: wantCount,
                youtube_video_id: null,
                video_urls: JSON.stringify(details.videos || []),
                url: `https://www.discogs.com/release/${releaseId}`,
                demand_coeff: computeRarityCoeff(haveCount, wantCount)
            };
            
            processedReleases.push(releaseData);
            
            updateJob(jobId, {
                progress: i + 1,
                currentStep: `Processing: ${i + 1} of ${newReleaseIds.length} new releases`
            });
            updateProgress(jobId);
            
            seller.releases = processedReleases;
            
            if ((i + 1) % 10 === 0 || i === newReleaseIds.length - 1) {
                await saveSellerDataToDB(seller);
                loadAllSellersData();
            }
            
            consecutiveErrors = 0;
            
        } catch (error) {
            console.error(`Error fetching details for release ${releaseId}:`, error);
            
            if (error.message.includes('Forbidden (403)')) {
                consecutiveErrors++;
                
                seller.releases = processedReleases;
                await saveSellerDataToDB(seller);
                loadAllSellersData();
                
                if (consecutiveErrors >= 3) {
                    updateJob(jobId, { 
                        status: 'complete', 
                        currentStep: `Processed ${i} new releases (rate limited)` 
                    });
                    updateProgress(jobId);
                    seller.lastUpdated = Date.now();
                    saveTrackedSellers();
                    finishJob(jobId, username);
                    return;
                }
                
                const waitMinutes = consecutiveErrors * 2;
                const waitMs = waitMinutes * 60 * 1000;
                
                updateJob(jobId, { 
                    currentStep: `Rate limited (403), waiting ${waitMinutes}min... (${i + 1}/${newReleaseIds.length})` 
                });
                updateProgress(jobId);
                await new Promise(resolve => setTimeout(resolve, waitMs));
                i--;
                continue;
            }
            
            if (error.message.includes('Rate limited')) {
                consecutiveErrors++;
                updateJob(jobId, { currentStep: `Rate limited (429), waiting 60s... (${i + 1}/${newReleaseIds.length})` });
                updateProgress(jobId);
                await new Promise(resolve => setTimeout(resolve, 60000));
                i--;
                continue;
            }
            
            console.warn(`Skipping release ${releaseId} due to error:`, error.message);
        }
    }
    
    seller.lastUpdated = Date.now();
    saveTrackedSellers();
    await saveSellerDataToDB(seller);
    updateSellerList();
    
    updateJob(jobId, {
        status: 'complete',
        currentStep: `Complete! Processed ${newReleaseIds.length} new releases.`,
        progress: newReleaseIds.length
    });
    updateProgress(jobId);
    
    loadAllSellersData();
    finishJob(jobId, username);
}

async function loadAllSellersData() {
    currentView = 'sellers';
    
    // Show sellers panel
    const sellersPanel = document.getElementById('sellersPanel');
    if (sellersPanel) sellersPanel.style.display = 'block';
    
    // Fetch wantlist IDs if logged in
    if (oauthUser && userAccessToken) {
        await fetchUserWantlistIds();
    }
    
    allData = [];
    
    const sellersToShow = selectedSellers.length > 0 ? selectedSellers : trackedSellers.map(s => s.username);
    
    sellersToShow.forEach(username => {
        const seller = trackedSellers.find(s => s.username === username);
        if (seller && seller.releases) {
            // Add seller info to each release and mark if in wantlist
            const releasesWithSeller = seller.releases.map(r => ({
                ...r,
                seller_username: username,
                inWantlist: userWantlistIds.has(r.id)
            }));
            allData.push(...releasesWithSeller);
        }
    });
    
    if (allData.length > 0) {
        hasSearched = true;
        const processingActive = isProcessingActive();
        displayResults(allData, processingActive);
    } else {
        const tbody = document.getElementById('releases-table-body');
        tbody.innerHTML = '<tr><td class="no-results" colspan="15"><p>No releases yet. Add sellers and they will appear here.</p></td></tr>';
    }
}

// ==================== HELPER FUNCTIONS ====================
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function bayesianRating(avgRating, numRatings, minNumRatings = 10) {
    if (numRatings === 0) return 0.0;
    const priorMean = 2.5;
    return (avgRating * numRatings + priorMean * minNumRatings) / (numRatings + minNumRatings);
}

function computeRarityCoeff(have, want) {
    const h = typeof have === 'number' ? have : parseFloat(have) || 0;
    const w = typeof want === 'number' ? want : parseFloat(want) || 0;
    return (w + 1) / (h + 1);
}

function getVideoUrl(video) {
    if (!video || typeof video !== 'object') return '';
    return video.url || video.uri || video.href || '';
}

function sanitizeVideoLinks(videoLinks) {
    if (!Array.isArray(videoLinks)) return [];
    const sanitized = [];
    videoLinks.forEach(video => {
        const url = getVideoUrl(video);
        if (!url) return;
        sanitized.push({
            url,
            title: video?.title || ''
        });
    });
    return sanitized;
}

function extractYouTubeID(url) {
    if (!url) return null;
    const regex = /(?:youtube\.com\/.*v=|youtu\.be\/)([^"&?/\s]{11})/;
    const match = url.match(regex);
    return match ? match[1] : null;
}

// ==================== USER AUTHENTICATION ====================

// Load user auth state from localStorage on init
function loadOAuthState() {
    const token = localStorage.getItem('discogs_user_token');
    const userStr = localStorage.getItem('oauth_user');
    
    if (token && userStr) {
        userAccessToken = token;
        try {
            oauthUser = JSON.parse(userStr);
            updateOAuthUI();
            // Fetch wantlist IDs in background
            fetchUserWantlistIds();
        } catch (e) {
            console.error('Failed to parse user data:', e);
        }
    } else if (token) {
        // Have token but no user data, fetch it
        userAccessToken = token;
        fetchUserIdentity();
    }
}

// Update UI based on auth state
function updateOAuthUI() {
    const collectionIcon = document.getElementById('collectionIcon');
    const wantlistIcon = document.getElementById('wantlistIcon');
    const tokenLoginSection = document.getElementById('tokenLoginSection');
    const tokenLoggedInSection = document.getElementById('tokenLoggedInSection');
    const profileUsername = document.getElementById('profileUsername');
    
    if (oauthUser) {
        // Show collection and wantlist icons
        if (collectionIcon) collectionIcon.style.display = 'inline-block';
        if (wantlistIcon) wantlistIcon.style.display = 'inline-block';
        
        // Update profile modal
        if (tokenLoginSection) tokenLoginSection.style.display = 'none';
        if (tokenLoggedInSection) tokenLoggedInSection.style.display = 'block';
        if (profileUsername) profileUsername.textContent = oauthUser.username;
    } else {
        // Hide collection and wantlist icons
        if (collectionIcon) collectionIcon.style.display = 'none';
        if (wantlistIcon) wantlistIcon.style.display = 'none';
        
        // Update profile modal
        if (tokenLoginSection) tokenLoginSection.style.display = 'block';
        if (tokenLoggedInSection) tokenLoggedInSection.style.display = 'none';
    }
}

// Toggle user dropdown menu
function toggleUserDropdown() {
    const menu = document.getElementById('userDropdownMenu');
    menu.classList.toggle('show');
}

// Close dropdown when clicking outside
document.addEventListener('click', function(e) {
    const userSection = document.getElementById('oauthUserSection');
    const menu = document.getElementById('userDropdownMenu');
    if (userSection && menu && !userSection.contains(e.target)) {
        menu.classList.remove('show');
    }
});

// Show OAuth login instructions
function showOAuthInstructions() {
    const modal = new bootstrap.Modal(document.getElementById('oauthLoginModal'));
    document.getElementById('userTokenInput').value = '';
    modal.show();
}

// Login with personal access token
async function loginWithToken() {
    const tokenInput = document.getElementById('userTokenInput');
    const token = tokenInput.value.trim();
    
    if (!token) {
        alert('Please enter your personal access token.');
        return;
    }
    
    // Store token
    userAccessToken = token;
    localStorage.setItem('discogs_user_token', token);
    
    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('oauthLoginModal'));
    if (modal) {
        modal.hide();
    }
    
    // Fetch user identity
    try {
        await fetchUserIdentity();
        alert('Successfully logged in to Discogs!');
    } catch (error) {
        console.error('Login error:', error);
        alert('Failed to login. Please check your token and try again.');
        userAccessToken = null;
        localStorage.removeItem('discogs_user_token');
    }
}

// Login with token from profile modal
async function loginWithTokenFromProfile() {
    const tokenInput = document.getElementById('profileTokenInput');
    const token = tokenInput.value.trim();
    
    if (!token) {
        alert('Please enter your personal access token.');
        return;
    }
    
    // Store token
    userAccessToken = token;
    localStorage.setItem('discogs_user_token', token);
    
    // Fetch user identity
    try {
        await fetchUserIdentity();
        alert('Successfully logged in to Discogs!');
        
        // Close modal after successful login
        const modal = bootstrap.Modal.getInstance(document.getElementById('profileModal'));
        if (modal) {
            modal.hide();
        }
    } catch (error) {
        console.error('Login error:', error);
        alert('Failed to login. Please check your token and try again.');
        userAccessToken = null;
        localStorage.removeItem('discogs_user_token');
    }
}

// Fetch authenticated user identity
async function fetchUserIdentity() {
    if (!userAccessToken) {
        return;
    }
    
    try {
        const identityUrl = 'https://api.discogs.com/oauth/identity';
        
        const response = await fetch(identityUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Discogs token=${userAccessToken}`,
                'User-Agent': 'DiscogsTrackr/1.0'
            }
        });
        
        if (!response.ok) {
            throw new Error(`Failed to fetch identity: ${response.status}`);
        }
        
        const userData = await response.json();
        oauthUser = userData;
        localStorage.setItem('oauth_user', JSON.stringify(userData));
        
        updateOAuthUI();
        
        // Fetch wantlist IDs in background
        fetchUserWantlistIds();
        
    } catch (error) {
        console.error('Failed to fetch user identity:', error);
        throw error;
    }
}

// Logout
function logoutOAuth() {
    oauthUser = null;
    userAccessToken = null;
    userWantlistIds.clear();
    cachedCollectionData = null;
    cachedWantlistData = null;
    lastCollectionIds.clear();
    lastWantlistIds.clear();
    
    localStorage.removeItem('discogs_user_token');
    localStorage.removeItem('oauth_user');
    
    updateOAuthUI();
    alert('Successfully logged out.');
}

// Make authenticated API request with token
async function makeAuthenticatedRequest(url) {
    if (!userAccessToken) {
        throw new Error('Not authenticated. Please log in first.');
    }
    
    const response = await fetch(url, {
        method: 'GET',
        headers: {
            'Authorization': `Discogs token=${userAccessToken}`,
            'User-Agent': 'DiscogsTrackr/1.0'
        }
    });
    
    if (!response.ok) {
        throw new Error(`Request failed: ${response.status}`);
    }
    
    return await response.json();
}

// Fetch user's wantlist IDs to check which releases are wanted
async function fetchUserWantlistIds() {
    if (!oauthUser || !userAccessToken) {
        return;
    }
    
    try {
        const username = oauthUser.username;
        // Fetch first page to get total
        const firstPageUrl = `https://api.discogs.com/users/${username}/wants?per_page=100&page=1`;
        const firstPage = await makeAuthenticatedRequest(firstPageUrl);
        
        userWantlistIds.clear();
        
        // Add IDs from first page
        if (firstPage.wants) {
            firstPage.wants.forEach(item => {
                userWantlistIds.add(item.basic_information.id);
            });
        }
        
        // Fetch remaining pages if needed
        const totalPages = firstPage.pagination?.pages || 1;
        if (totalPages > 1) {
            const pagePromises = [];
            for (let page = 2; page <= Math.min(totalPages, 10); page++) { // Limit to 10 pages (1000 items)
                const pageUrl = `https://api.discogs.com/users/${username}/wants?per_page=100&page=${page}`;
                pagePromises.push(makeAuthenticatedRequest(pageUrl));
            }
            
            const pages = await Promise.all(pagePromises);
            pages.forEach(pageData => {
                if (pageData.wants) {
                    pageData.wants.forEach(item => {
                        userWantlistIds.add(item.basic_information.id);
                    });
                }
            });
        }
        
        console.log(`Loaded ${userWantlistIds.size} items from wantlist`);
    } catch (error) {
        console.error('Failed to fetch wantlist IDs:', error);
    }
}

// Show user collection
async function showUserCollection() {
    if (!oauthUser) {
        alert('Please log in first. Go to Profile to enter your access token.');
        return;
    }
    
    currentView = 'collection';
    
    // Hide sellers panel
    const sellersPanel = document.getElementById('sellersPanel');
    if (sellersPanel) sellersPanel.style.display = 'none';
    
    // Show loading in table
    const tbody = document.getElementById('releases-table-body');
    tbody.innerHTML = '<tr><td colspan="15" class="text-center py-5"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div><p class="mt-2">Loading your collection...</p></td></tr>';
    
    try {
        const username = oauthUser.username;
        const collectionUrl = `https://api.discogs.com/users/${username}/collection/folders/0/releases?per_page=100`;
        
        const data = await makeAuthenticatedRequest(collectionUrl);
        
        if (!data.releases || data.releases.length === 0) {
            tbody.innerHTML = '<tr><td colspan="15" class="text-center py-5"><div class="alert alert-info">Your collection is empty.</div></td></tr>';
            return;
        }
        
        // Get current release IDs
        const currentCollectionIds = new Set(data.releases.map(item => item.basic_information.id));
        
        // Determine what changed
        const addedIds = [...currentCollectionIds].filter(id => !lastCollectionIds.has(id));
        const removedIds = [...lastCollectionIds].filter(id => !currentCollectionIds.has(id));
        
        // Check if we have cached data and only need to update
        if (cachedCollectionData && (addedIds.length > 0 || removedIds.length > 0)) {
            // Incremental update
            console.log(`Collection changed: +${addedIds.length} added, -${removedIds.length} removed`);
            
            // Remove deleted items from cache
            let updatedCollection = cachedCollectionData.filter(item => !removedIds.includes(item.id));
            
            if (addedIds.length > 0) {
                // Show enriching status for new items
                tbody.innerHTML = `<tr><td colspan="15" class="text-center py-5">
                    <div class="spinner-border" role="status"></div>
                    <p class="mt-2 mb-1">Enriching ${addedIds.length} new item(s)...</p>
                    <p class="mb-0" id="enrichProgress"><strong>0 / ${addedIds.length}</strong> (0%)</p>
                </td></tr>`;
                
                // Enrich only new items
                for (let i = 0; i < addedIds.length; i++) {
                    const releaseId = addedIds[i];
                    const item = data.releases.find(r => r.basic_information.id === releaseId);
                    const release = item.basic_information;
                    
                    try {
                        // Fetch full release data
                        const fullRelease = await makeDiscogsRequest(`https://api.discogs.com/releases/${release.id}`);
                        
                        const enrichedRelease = {
                            id: release.id,
                            title: fullRelease.title || release.title,
                            artist: release.artists?.map(a => a.name).join(', ') || '',
                            artist_title: fullRelease.title || release.title,
                            label: release.labels?.map(l => l.name).join(', ') || '',
                            year: fullRelease.year || release.year || '',
                            genres: JSON.stringify(fullRelease.genres || release.genres || []),
                            styles: JSON.stringify(fullRelease.styles || release.styles || []),
                            url: `https://www.discogs.com/release/${release.id}`,
                            avg_rating: fullRelease.community?.rating?.average || 0,
                            num_ratings: fullRelease.community?.rating?.count || 0,
                            seller_username: 'My Collection',
                            demand_coeff: fullRelease.community ? (fullRelease.community.want + 1) / (fullRelease.community.have + 1) : 0,
                            have_count: fullRelease.community?.have || 0,
                            want_count: fullRelease.community?.want || 0,
                            price: 0,
                            video_urls: JSON.stringify(fullRelease.videos || []),
                            bayesian_score: fullRelease.community?.rating?.average || 0,
                            inWantlist: userWantlistIds.has(release.id)
                        };
                        
                        updatedCollection.push(enrichedRelease);
                    } catch (error) {
                        console.error(`Failed to fetch full data for release ${release.id}:`, error);
                    }
                    
                    // Update progress
                    const progressEl = document.getElementById('enrichProgress');
                    if (progressEl) {
                        const completed = i + 1;
                        const percentage = Math.round((completed / addedIds.length) * 100);
                        progressEl.innerHTML = `<strong>${completed} / ${addedIds.length}</strong> (${percentage}%)`;
                    }
                }
            }
            
            // Update cache and IDs
            cachedCollectionData = updatedCollection;
            lastCollectionIds = currentCollectionIds;
            
            // Display updated data
            allData = updatedCollection;
            hasSearched = true;
            displayResults(updatedCollection, false);
            
        } else if (cachedCollectionData && addedIds.length === 0 && removedIds.length === 0) {
            // No changes, use cached data
            console.log('Collection unchanged, using cache');
            allData = cachedCollectionData;
            hasSearched = true;
            displayResults(cachedCollectionData, false);
            
        } else {
            // First time or cache invalidated - full enrichment
            console.log('Performing full collection enrichment');
            
            // Fetch full release data for each item to get ratings, have/want, videos
            const totalItems = data.releases.length;
            tbody.innerHTML = `<tr><td colspan="15" class="text-center py-5">
                <div class="spinner-border" role="status"></div>
                <p class="mt-2 mb-1">Enriching collection data...</p>
                <p class="mb-0" id="enrichProgress"><strong>0 / ${totalItems}</strong> (0%)</p>
            </td></tr>`;
            
            const collectionReleases = [];
            for (let i = 0; i < data.releases.length; i++) {
                const item = data.releases[i];
                const release = item.basic_information;
            
            try {
                // Fetch full release data
                const fullRelease = await makeDiscogsRequest(`https://api.discogs.com/releases/${release.id}`);
                
                const enrichedRelease = {
                    id: release.id,
                    title: fullRelease.title || release.title,
                    artist: release.artists?.map(a => a.name).join(', ') || '',
                    artist_title: fullRelease.title || release.title,
                    label: release.labels?.map(l => l.name).join(', ') || '',
                    year: fullRelease.year || release.year || '',
                    genres: JSON.stringify(fullRelease.genres || release.genres || []),
                    styles: JSON.stringify(fullRelease.styles || release.styles || []),
                    url: `https://www.discogs.com/release/${release.id}`,
                    avg_rating: fullRelease.community?.rating?.average || 0,
                    num_ratings: fullRelease.community?.rating?.count || 0,
                    seller_username: 'My Collection',
                    demand_coeff: fullRelease.community ? (fullRelease.community.want + 1) / (fullRelease.community.have + 1) : 0,
                    have_count: fullRelease.community?.have || 0,
                    want_count: fullRelease.community?.want || 0,
                    price: 0,
                    video_urls: JSON.stringify(fullRelease.videos || []),
                    bayesian_score: fullRelease.community?.rating?.average || 0
                };
                
                collectionReleases.push(enrichedRelease);
            } catch (error) {
                console.error(`Failed to fetch full data for release ${release.id}:`, error);
                // Fallback to basic data
                collectionReleases.push({
                    id: release.id,
                    title: release.title,
                    artist: release.artists?.map(a => a.name).join(', ') || '',
                    artist_title: release.title,
                    label: release.labels?.map(l => l.name).join(', ') || '',
                    year: release.year || '',
                    genres: JSON.stringify(release.genres || []),
                    styles: JSON.stringify(release.styles || []),
                    url: `https://www.discogs.com/release/${release.id}`,
                    avg_rating: 0,
                    num_ratings: 0,
                    seller_username: 'My Collection',
                    demand_coeff: 0,
                    have_count: 0,
                    want_count: 0,
                    price: 0,
                    video_urls: JSON.stringify([]),
                    bayesian_score: 0
                });
            }
            
            // Update progress
            const progressEl = document.getElementById('enrichProgress');
            if (progressEl) {
                const completed = i + 1;
                const percentage = Math.round((completed / totalItems) * 100);
                progressEl.innerHTML = `<strong>${completed} / ${totalItems}</strong> (${percentage}%)`;
                }
            }
            
            // Cache the enriched data and save IDs
            cachedCollectionData = collectionReleases;
            lastCollectionIds = currentCollectionIds;
            
            // Display in table
            allData = collectionReleases;
            hasSearched = true;
            displayResults(collectionReleases, false);
        }
        
    } catch (error) {
        console.error('Failed to fetch collection:', error);
        tbody.innerHTML = '<tr><td colspan="15" class="text-center py-5"><div class="alert alert-danger">Failed to load collection. Please try again.</div></td></tr>';
    }
}

// Show user wantlist
async function showUserWantlist() {
    if (!oauthUser) {
        alert('Please log in first. Go to Profile to enter your access token.');
        return;
    }
    
    currentView = 'wantlist';
    
    // Hide sellers panel
    const sellersPanel = document.getElementById('sellersPanel');
    if (sellersPanel) sellersPanel.style.display = 'none';
    
    // Show loading in table
    const tbody = document.getElementById('releases-table-body');
    tbody.innerHTML = '<tr><td colspan="15" class="text-center py-5"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div><p class="mt-2">Loading your wantlist...</p></td></tr>';
    
    try {
        const username = oauthUser.username;
        const wantlistUrl = `https://api.discogs.com/users/${username}/wants?per_page=100`;
        
        const data = await makeAuthenticatedRequest(wantlistUrl);
        
        if (!data.wants || data.wants.length === 0) {
            tbody.innerHTML = '<tr><td colspan="15" class="text-center py-5"><div class="alert alert-info">Your wantlist is empty.</div></td></tr>';
            return;
        }
        
        // Get current release IDs
        const currentWantlistIds = new Set(data.wants.map(item => item.basic_information.id));
        
        // Determine what changed
        const addedIds = [...currentWantlistIds].filter(id => !lastWantlistIds.has(id));
        const removedIds = [...lastWantlistIds].filter(id => !currentWantlistIds.has(id));
        
        // Check if we have cached data and only need to update
        if (cachedWantlistData && (addedIds.length > 0 || removedIds.length > 0)) {
            // Incremental update
            console.log(`Wantlist changed: +${addedIds.length} added, -${removedIds.length} removed`);
            
            // Remove deleted items from cache
            let updatedWantlist = cachedWantlistData.filter(item => !removedIds.includes(item.id));
            
            if (addedIds.length > 0) {
                // Show enriching status for new items
                tbody.innerHTML = `<tr><td colspan="15" class="text-center py-5">
                    <div class="spinner-border" role="status"></div>
                    <p class="mt-2 mb-1">Enriching ${addedIds.length} new item(s)...</p>
                    <p class="mb-0" id="enrichProgress"><strong>0 / ${addedIds.length}</strong> (0%)</p>
                </td></tr>`;
                
                // Enrich only new items
                for (let i = 0; i < addedIds.length; i++) {
                    const releaseId = addedIds[i];
                    const item = data.wants.find(w => w.basic_information.id === releaseId);
                    const release = item.basic_information;
                    
                    try {
                        // Fetch full release data
                        const fullRelease = await makeDiscogsRequest(`https://api.discogs.com/releases/${release.id}`);
                        
                        const enrichedRelease = {
                            id: release.id,
                            title: fullRelease.title || release.title,
                            artist: release.artists?.map(a => a.name).join(', ') || '',
                            artist_title: fullRelease.title || release.title,
                            label: release.labels?.map(l => l.name).join(', ') || '',
                            year: fullRelease.year || release.year || '',
                            genres: JSON.stringify(fullRelease.genres || release.genres || []),
                            styles: JSON.stringify(fullRelease.styles || release.styles || []),
                            url: `https://www.discogs.com/release/${release.id}`,
                            avg_rating: fullRelease.community?.rating?.average || 0,
                            num_ratings: fullRelease.community?.rating?.count || 0,
                            seller_username: 'My Wantlist',
                            demand_coeff: fullRelease.community ? (fullRelease.community.want + 1) / (fullRelease.community.have + 1) : 0,
                            have_count: fullRelease.community?.have || 0,
                            want_count: fullRelease.community?.want || 0,
                            price: 0,
                            video_urls: JSON.stringify(fullRelease.videos || []),
                            bayesian_score: fullRelease.community?.rating?.average || 0,
                            notes: item.notes || '',
                            inWantlist: true
                        };
                        
                        updatedWantlist.push(enrichedRelease);
                    } catch (error) {
                        console.error(`Failed to fetch full data for release ${release.id}:`, error);
                    }
                    
                    // Update progress
                    const progressEl = document.getElementById('enrichProgress');
                    if (progressEl) {
                        const completed = i + 1;
                        const percentage = Math.round((completed / addedIds.length) * 100);
                        progressEl.innerHTML = `<strong>${completed} / ${addedIds.length}</strong> (${percentage}%)`;
                    }
                }
            }
            
            // Update cache and IDs
            cachedWantlistData = updatedWantlist;
            lastWantlistIds = currentWantlistIds;
            
            // Display updated data
            allData = updatedWantlist;
            hasSearched = true;
            displayResults(updatedWantlist, false);
            
        } else if (cachedWantlistData && addedIds.length === 0 && removedIds.length === 0) {
            // No changes, use cached data
            console.log('Wantlist unchanged, using cache');
            allData = cachedWantlistData;
            hasSearched = true;
            displayResults(cachedWantlistData, false);
            
        } else {
            // First time or cache invalidated - full enrichment
            console.log('Performing full wantlist enrichment');
            
            // Fetch full release data for each item to get ratings, have/want, videos
            const totalItems = data.wants.length;
            tbody.innerHTML = `<tr><td colspan="15" class="text-center py-5">
                <div class="spinner-border" role="status"></div>
                <p class="mt-2 mb-1">Enriching wantlist data...</p>
                <p class="mb-0" id="enrichProgress"><strong>0 / ${totalItems}</strong> (0%)</p>
            </td></tr>`;
            
            const wantlistReleases = [];
            for (let i = 0; i < data.wants.length; i++) {
                const item = data.wants[i];
                const release = item.basic_information;
            
            try {
                // Fetch full release data
                const fullRelease = await makeDiscogsRequest(`https://api.discogs.com/releases/${release.id}`);
                
                const enrichedRelease = {
                    id: release.id,
                    title: fullRelease.title || release.title,
                    artist: release.artists?.map(a => a.name).join(', ') || '',
                    artist_title: fullRelease.title || release.title,
                    label: release.labels?.map(l => l.name).join(', ') || '',
                    year: fullRelease.year || release.year || '',
                    genres: JSON.stringify(fullRelease.genres || release.genres || []),
                    styles: JSON.stringify(fullRelease.styles || release.styles || []),
                    url: `https://www.discogs.com/release/${release.id}`,
                    avg_rating: fullRelease.community?.rating?.average || 0,
                    num_ratings: fullRelease.community?.rating?.count || 0,
                    seller_username: 'My Wantlist',
                    demand_coeff: fullRelease.community ? (fullRelease.community.want + 1) / (fullRelease.community.have + 1) : 0,
                    have_count: fullRelease.community?.have || 0,
                    want_count: fullRelease.community?.want || 0,
                    price: 0,
                    video_urls: JSON.stringify(fullRelease.videos || []),
                    bayesian_score: fullRelease.community?.rating?.average || 0,
                    notes: item.notes || '',
                    inWantlist: true // Mark as in wantlist
                };
                
                wantlistReleases.push(enrichedRelease);
            } catch (error) {
                console.error(`Failed to fetch full data for release ${release.id}:`, error);
                // Fallback to basic data
                wantlistReleases.push({
                    id: release.id,
                    title: release.title,
                    artist: release.artists?.map(a => a.name).join(', ') || '',
                    artist_title: release.title,
                    label: release.labels?.map(l => l.name).join(', ') || '',
                    year: release.year || '',
                    genres: JSON.stringify(release.genres || []),
                    styles: JSON.stringify(release.styles || []),
                    url: `https://www.discogs.com/release/${release.id}`,
                    avg_rating: 0,
                    num_ratings: 0,
                    seller_username: 'My Wantlist',
                    demand_coeff: 0,
                    have_count: 0,
                    want_count: 0,
                    price: 0,
                    video_urls: JSON.stringify([]),
                    bayesian_score: 0,
                    notes: item.notes || '',
                    inWantlist: true
                });
            }
            
            // Update progress
            const progressEl = document.getElementById('enrichProgress');
            if (progressEl) {
                const completed = i + 1;
                const percentage = Math.round((completed / totalItems) * 100);
                progressEl.innerHTML = `<strong>${completed} / ${totalItems}</strong> (${percentage}%)`;
                }
            }
            
            // Cache the enriched data and save IDs
            cachedWantlistData = wantlistReleases;
            lastWantlistIds = currentWantlistIds;
            
            // Display in table
            allData = wantlistReleases;
            hasSearched = true;
            displayResults(wantlistReleases, false);
        }
        
    } catch (error) {
        console.error('Failed to fetch wantlist:', error);
        tbody.innerHTML = '<tr><td colspan="15" class="text-center py-5"><div class="alert alert-danger">Failed to load wantlist. Please try again.</div></td></tr>';
    }
}

// Toggle release in wantlist (add or remove)
async function toggleWantlist(releaseId, buttonElement) {
    if (!oauthUser || !userAccessToken) {
        alert('Please log in with Discogs to manage your wantlist.');
        return;
    }
    
    const isInWantlist = userWantlistIds.has(releaseId);
    
    try {
        const username = oauthUser.username;
        const wantlistUrl = `https://api.discogs.com/users/${username}/wants/${releaseId}`;
        
        if (isInWantlist) {
            // Remove from wantlist
            const response = await fetch(wantlistUrl, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Discogs token=${userAccessToken}`,
                    'User-Agent': 'DiscogsTrackr/1.0'
                }
            });
            
                if (response.status === 204) {
                    // Successfully removed
                    userWantlistIds.delete(releaseId);
                    
                    // Update cached data
                    if (cachedCollectionData) {
                        const item = cachedCollectionData.find(r => r.id === releaseId);
                        if (item) item.inWantlist = false;
                    }
                    if (cachedWantlistData) {
                        // Remove from cached wantlist
                        cachedWantlistData = cachedWantlistData.filter(r => r.id !== releaseId);
                    }
                    
                    if (buttonElement) {
                        buttonElement.innerHTML = '<i class="bi bi-heart" style="color: #fff;"></i>';
                        buttonElement.onclick = () => toggleWantlist(releaseId, buttonElement);
                    }
                    
                    // If we're viewing wantlist, refresh the display
                    if (currentView === 'wantlist') {
                        showUserWantlist();
                    }
                } else {
                    throw new Error(`Failed to remove from wantlist: ${response.status}`);
                }
        } else {
            // Add to wantlist
            const response = await fetch(wantlistUrl, {
                method: 'PUT',
                headers: {
                    'Authorization': `Discogs token=${userAccessToken}`,
                    'User-Agent': 'DiscogsTrackr/1.0'
                }
            });
            
            if (response.status === 201 || response.status === 204) {
                // Successfully added
                userWantlistIds.add(releaseId);
                
                // Update cached data
                if (cachedCollectionData) {
                    const item = cachedCollectionData.find(r => r.id === releaseId);
                    if (item) item.inWantlist = true;
                }
                
                if (buttonElement) {
                    buttonElement.innerHTML = '<i class="bi bi-heart-fill" style="color: var(--accent-color);"></i>';
                    buttonElement.onclick = () => toggleWantlist(releaseId, buttonElement);
                }
            } else {
                throw new Error(`Failed to add to wantlist: ${response.status}`);
            }
        }
        
    } catch (error) {
        console.error('Failed to update wantlist:', error);
        alert('Failed to update wantlist. Please try again.');
    }
}

// ==================== DISCOGS API CALLS ====================
let lastRequestTime = 0;
const MIN_REQUEST_INTERVAL = 1000;
let requestCount = 0;
let requestWindowStart = Date.now();
const MAX_REQUESTS_PER_MINUTE = 60; // Conservative limit (Discogs allows 60)
// Global request queue to strictly serialize Discogs API calls
let requestQueue = Promise.resolve();

async function makeDiscogsRequest(url) {
    const consumerKey = localStorage.getItem('discogs_consumer_key');
    const consumerSecret = localStorage.getItem('discogs_consumer_secret');
    if (!consumerKey || !consumerSecret) {
        throw new Error('Discogs credentials not configured. Please go to Settings.');
    }
    // Enqueue this request to ensure global rate limiting
    requestQueue = requestQueue.then(async () => {
        const now = Date.now();
        
        // Reset counter if we're in a new minute window
        if (now - requestWindowStart >= 60000) {
            requestCount = 0;
            requestWindowStart = now;
        }
        
        // If we've hit the per-minute limit, wait until the next window
        if (requestCount >= MAX_REQUESTS_PER_MINUTE) {
            const waitTime = 60000 - (now - requestWindowStart);
            if (waitTime > 0) {
                console.log(`Rate limit: waiting ${Math.ceil(waitTime / 1000)}s before next request`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
                requestCount = 0;
                requestWindowStart = Date.now();
            }
        }
        
        // Ensure minimum interval between requests
        const timeSinceLastRequest = now - lastRequestTime;
        if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {
            await new Promise(resolve => setTimeout(resolve, MIN_REQUEST_INTERVAL - timeSinceLastRequest));
        }
        
        const fullUrl = `${url}${url.includes('?') ? '&' : '?'}key=${consumerKey}&secret=${consumerSecret}`;
        const response = await fetch(fullUrl, {
            headers: {
                'User-Agent': 'DiscogsSellerApp/1.0',
                'Accept': 'application/json'
            }
        });
        lastRequestTime = Date.now();
        requestCount++;
        
        if (response.status === 429) {
            const retryAfter = parseInt(response.headers.get('Retry-After') || '60');
            throw new Error(`Rate limited. Please wait ${retryAfter} seconds.`);
        }
        if (response.status === 403) {
            throw new Error('Forbidden (403). Likely rate limited by Discogs.');
        }
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    });
    // Return the enqueued promise to caller
    return requestQueue;
}

async function getSellerInventory(username, page = 1, perPage = 100) {
    const url = `https://api.discogs.com/users/${username}/inventory?page=${page}&per_page=${perPage}`;
    return await makeDiscogsRequest(url);
}

async function getReleaseDetails(releaseId) {
    const url = `https://api.discogs.com/releases/${releaseId}`;
    return await makeDiscogsRequest(url);
}

// ==================== JOB MANAGEMENT ====================
function checkForStoredJob() {
    const storedJobId = localStorage.getItem('currentJobId');
    const storedUsername = localStorage.getItem('currentUsername');
    
    if (storedJobId && storedUsername) {
        currentJobId = storedJobId;
        
        const job = getJobFromStorage(storedJobId);
        if (job && job.status === 'processing') {
            // Update seller's currentJob
            const seller = trackedSellers.find(s => s.username === storedUsername);
            if (seller) {
                seller.currentJob = job;
                updateSellerList();
            }
            resumeJob(storedJobId, storedUsername);
        } else if (job && job.status === 'complete') {
            localStorage.removeItem('currentJobId');
            localStorage.removeItem('currentUsername');
        }
    }
}

function createJob(jobId, username) {
    const job = {
        jobId,
        username,
        status: 'processing',
        progress: 0,
        total: 0,
        currentStep: 'Initializing...',
        createdAt: Date.now()
    };
    try {
        localStorage.setItem(`job_${jobId}`, JSON.stringify(job));
    } catch (e) {
        console.error('Failed to store job in localStorage:', e);
        // Try emergency cleanup and retry once
        if (e.name === 'QuotaExceededError') {
            console.log('Attempting emergency cleanup...');
            if (aggressiveCleanupLocalStorage()) {
                try {
                    localStorage.setItem(`job_${jobId}`, JSON.stringify(job));
                    console.log('Job stored after cleanup');
                } catch (e2) {
                    console.error('Still failed after cleanup:', e2);
                }
            }
        }
    }
    return job;
}

function updateJob(jobId, updates) {
    const jobStr = localStorage.getItem(`job_${jobId}`);
    if (!jobStr) return null;
    
    const job = JSON.parse(jobStr);
    // Don't store processedReleases array to avoid quota issues
    if (updates.processedReleases) {
        delete updates.processedReleases;
    }
    Object.assign(job, updates);
    try {
        localStorage.setItem(`job_${jobId}`, JSON.stringify(job));
    } catch (e) {
        console.error('Failed to update job in localStorage (quota exceeded):', e);
        // Job will continue in memory even if we can't persist it
    }
    return job;
}

function getJobFromStorage(jobId) {
    const jobStr = localStorage.getItem(`job_${jobId}`);
    return jobStr ? JSON.parse(jobStr) : null;
}

// ==================== MAIN FETCH LOGIC ====================
// Fetch inventory only (for new sellers or when inventory needs refresh)
async function fetchSellerInventory(username) {
    const seller = trackedSellers.find(s => s.username === username);
    if (!seller) return;
    
    const jobId = 'job_' + Date.now();
    currentJobId = jobId;
    
    try {
        localStorage.setItem('currentJobId', jobId);
        localStorage.setItem('currentUsername', username);
    } catch (e) {
        console.warn('Could not store job metadata in localStorage:', e);
    }
    
    const job = createJob(jobId, username);
    seller.currentJob = job;
    updateSellerList();
    
    await fetchInventoryOnly(jobId, username);
}

// Process releases from cached inventory (incremental)
async function processSellerReleases(username) {
    const seller = trackedSellers.find(s => s.username === username);
    if (!seller) return;
    
    if (!seller.inventory || seller.inventory.length === 0) {
        alert('No inventory cached. Please fetch inventory first.');
        return;
    }
    
    const jobId = 'job_' + Date.now();
    currentJobId = jobId;
    
    try {
        localStorage.setItem('currentJobId', jobId);
        localStorage.setItem('currentUsername', username);
    } catch (e) {
        console.warn('Could not store job metadata in localStorage:', e);
    }
    
    const job = createJob(jobId, username);
    seller.currentJob = job;
    updateSellerList();
    
    await processReleasesFromInventory(jobId, username);
}

// Legacy function for backward compatibility (fetches inventory then processes)
async function fetchSellerData(username, forceRefresh = false) {
    if (forceRefresh) {
        await fetchSellerInventory(username);
    } else {
        await processSellerReleases(username);
    }
}

// Fetch inventory only - no release processing
async function fetchInventoryOnly(jobId, username) {
    try {
        const seller = trackedSellers.find(s => s.username === username);
        if (!seller) return;
        
        let allListings = [];
            updateJob(jobId, { currentStep: 'Fetching inventory...' });
            updateProgress(jobId);
            
            let page = 1;
            const perPage = 100;
            let consecutive403s = 0;
            
            while (true) {
                try {
                    const inventory = await getSellerInventory(username, page, perPage);
                    const listings = inventory.listings || [];
                    
                    // Reset 403 counter on success
                    consecutive403s = 0;
                    
                    if (listings.length === 0) break;
                    
                    allListings.push(...listings);
                    
                    const totalPages = inventory.pagination?.pages || 1;
                    updateJob(jobId, {
                        currentStep: `Fetching inventory: Page ${page} of ${totalPages}`,
                        progress: page,
                        total: totalPages
                    });
                    updateProgress(jobId);
                    
                    if (page >= totalPages) break;
                    page++;
                } catch (error) {
                    console.error(`Error fetching inventory page ${page}:`, error);
                    if (error.message.includes('Forbidden (403)')) {
                        // Discogs limits inventory pagination to 100 pages for non-owned inventories
                        if (page >= 100) {
                            console.log(`‚úì Reached Discogs pagination limit at page ${page}. Successfully fetched ${allListings.length} items (10,000 max for non-owned inventories).`);
                            updateJob(jobId, { 
                                currentStep: `Fetched ${allListings.length} items (100-page limit reached)` 
                            });
                            updateProgress(jobId);
                            break; // Continue processing with what we have
                        }
                        
                        consecutive403s++;
                        if (consecutive403s >= 3) {
                            updateJob(jobId, { 
                                status: 'error', 
                                currentStep: 'Discogs API error 403: Rate limit exceeded. Wait 5 minutes and try again.' 
                            });
                            updateProgress(jobId);
                            finishJob(jobId, username);
                            return;
                        }
                        // Exponential backoff: 60s, 120s
                        const waitTime = 60000 * Math.pow(2, consecutive403s - 1);
                        updateJob(jobId, { 
                            currentStep: `Rate limited (403), waiting ${waitTime / 1000}s before retry ${consecutive403s}/3...` 
                        });
                        updateProgress(jobId);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        continue; // Retry same page
                    }
                    if (error.message.includes('Rate limited')) {
                        updateJob(jobId, { currentStep: 'Rate limited (429), waiting 60s...' });
                        updateProgress(jobId);
                        await new Promise(resolve => setTimeout(resolve, 60000));
                        continue;
                    }
                    if (allListings.length > 0) break;
                    throw error;
                }
            }
            
        // Save inventory
        seller.inventory = allListings;
        await saveSellerDataToDB(seller);
        
        if (allListings.length === 0) {
            updateJob(jobId, {
                status: 'error',
                currentStep: 'No listings found for this seller'
            });
            updateProgress(jobId);
            finishJob(jobId, username);
            return;
        }
        
        // Complete inventory fetch
        seller.lastUpdated = Date.now();
        saveTrackedSellers();
        updateJob(jobId, {
            status: 'complete',
            currentStep: `Inventory fetched: ${allListings.length} items. Click refresh again to process releases.`
        });
        updateProgress(jobId);
        finishJob(jobId, username);
        
    } catch (error) {
        console.error('Error fetching inventory:', error);
        updateJob(jobId, {
            status: 'error',
            currentStep: `Error: ${error.message}`
        });
        updateProgress(jobId);
        finishJob(jobId, username);
    }
}

// Process releases from cached inventory (batch of 50)
async function processReleasesFromInventory(jobId, username) {
    try {
        const seller = trackedSellers.find(s => s.username === username);
        if (!seller) return;
        
        const allListings = seller.inventory || [];
        
        if (allListings.length === 0) {
            updateJob(jobId, {
                status: 'error',
                currentStep: 'No inventory cached'
            });
            updateProgress(jobId);
            finishJob(jobId, username);
            return;
        }
        
        updateJob(jobId, { currentStep: 'Analyzing inventory...' });
        updateProgress(jobId);
        
        // Process unique releases
        const uniqueReleases = {};
        for (const listing of allListings) {
            const release = listing.release;
            if (!release || !release.id) continue;
            
            const price = parseFloat(listing.price?.value || 0);
            if (!uniqueReleases[release.id] || (price > 0 && price < uniqueReleases[release.id].price)) {
                uniqueReleases[release.id] = {
                    id: release.id,
                    artist: release.artist || 'Unknown Artist',
                    title: release.title || 'Unknown Title',
                    price: price
                };
            }
        }
        
        const releaseIds = Object.keys(uniqueReleases);
        
        // Check which releases we already have details for
        const existingReleases = seller.releases || [];
        const existingIds = new Set(existingReleases.map(r => r.id));
        const newReleaseIds = releaseIds.filter(id => !existingIds.has(parseInt(id)));
        const removedIds = existingReleases.filter(r => !releaseIds.includes(r.id.toString())).map(r => r.id);
        
        // Remove releases no longer in inventory
        if (removedIds.length > 0) {
            seller.releases = existingReleases.filter(r => !removedIds.includes(r.id));
            console.log(`Removed ${removedIds.length} releases no longer in inventory`);
            await saveSellerDataToDB(seller);
        }
        
        // If no new releases, we're done
        if (newReleaseIds.length === 0) {
            updateJob(jobId, {
                status: 'complete',
                currentStep: 'All releases up to date!',
                progress: releaseIds.length,
                total: releaseIds.length
            });
            updateProgress(jobId);
            
            seller.lastUpdated = Date.now();
            saveTrackedSellers();
            await saveSellerDataToDB(seller);
            updateSellerList();
            loadAllSellersData();
            finishJob(jobId, username);
            return;
        }
        
        updateJob(jobId, {
            total: newReleaseIds.length,
            progress: 0,
            currentStep: `Fetching details for ${newReleaseIds.length} new releases...`
        });
        updateProgress(jobId);
        
        // Fetch details for all new releases with automatic rate limit handling
        const processedReleases = [...existingReleases];
        const BATCH_SIZE = 50; // Process 50, then pause if hit rate limit
        let consecutiveErrors = 0;
        
        for (let i = 0; i < newReleaseIds.length; i++) {
            const job = getJobFromStorage(jobId);
            if (job && job.status === 'cancelled') {
                console.log('Job cancelled');
                return;
            }
            
            const releaseId = newReleaseIds[i];
            const basicInfo = uniqueReleases[releaseId];
            
            try {
                const details = await getReleaseDetails(releaseId);
                
                const ratingData = details.community?.rating || {};
                const avgRating = parseFloat(ratingData.average || 0);
                const numRatings = parseInt(ratingData.count || 0);
                const bayesianScore = bayesianRating(avgRating, numRatings);
                
                const haveCount = parseInt(details.community?.have || 0);
                const wantCount = parseInt(details.community?.want || 0);
                
                const releaseData = {
                    id: parseInt(releaseId),
                    artist_title: `${basicInfo.artist} - ${basicInfo.title}`,
                    artist: details.artists?.[0]?.name || basicInfo.artist,
                    title: details.title || basicInfo.title,
                    label: details.labels?.[0]?.name || null,
                    year: details.year || null,
                    genres: JSON.stringify(details.genres || []),
                    styles: JSON.stringify(details.styles || []),
                    avg_rating: avgRating,
                    num_ratings: numRatings,
                    bayesian_score: bayesianScore,
                    price: basicInfo.price,
                    condition: basicInfo.condition || '',
                    have_count: haveCount,
                    want_count: wantCount,
                    youtube_video_id: null,
                    video_urls: JSON.stringify(details.videos || []),
                    url: `https://www.discogs.com/release/${releaseId}`,
                    demand_coeff: computeRarityCoeff(haveCount, wantCount)
                };
                
                processedReleases.push(releaseData);
                
                updateJob(jobId, {
                    progress: i + 1,
                    currentStep: `Processing: ${i + 1} of ${newReleaseIds.length} new releases`
                });
                updateProgress(jobId);
                
                // Update seller data incrementally
                seller.releases = processedReleases;
                
                // Update display every 10 releases
                if ((i + 1) % 10 === 0 || i === newReleaseIds.length - 1) {
                    await saveSellerDataToDB(seller);
                    loadAllSellersData();
                }
                
            } catch (error) {
                console.error(`Error fetching details for release ${releaseId} (${i + 1}/${newReleaseIds.length}):`, error);
                
                if (error.message.includes('Forbidden (403)')) {
                    consecutiveErrors++;
                    
                    // Save progress after every batch
                    seller.releases = processedReleases;
                    await saveSellerDataToDB(seller);
                    loadAllSellersData();
                    
                    // Check if we're at a batch boundary (every 50 releases)
                    const isAtBatchBoundary = (i + 1) % BATCH_SIZE === 0 || i === 0;
                    
                    if (consecutiveErrors >= 3 && !isAtBatchBoundary) {
                        // Too many errors mid-batch, give up
                        console.warn(`Too many 403 errors at ${i + 1}/${newReleaseIds.length}`);
                        updateJob(jobId, { 
                            status: 'complete', 
                            currentStep: `Processed ${processedReleases.length}/${releaseIds.length} releases (hit rate limit)` 
                        });
                        updateProgress(jobId);
                        seller.lastUpdated = Date.now();
                        saveTrackedSellers();
                        finishJob(jobId, username);
                        return;
                    }
                    
                    // Wait progressively longer based on position in batch
                    const waitMinutes = isAtBatchBoundary ? 3 : consecutiveErrors * 2; // 3min at batch boundary, or 2/4/6 min
                    const waitMs = waitMinutes * 60 * 1000;
                    
                    console.warn(`403 at release ${i + 1}. Waiting ${waitMinutes} min before retry...`);
                    updateJob(jobId, { 
                        currentStep: `Rate limited (403), waiting ${waitMinutes}min... (${i + 1}/${newReleaseIds.length})` 
                    });
                    updateProgress(jobId);
                    await new Promise(resolve => setTimeout(resolve, waitMs));
                    i--; // Retry this release
                    continue;
                }
                
                if (error.message.includes('Rate limited')) {
                    consecutiveErrors++;
                    updateJob(jobId, { currentStep: `Rate limited (429), waiting 60s... (${i + 1}/${newReleaseIds.length})` });
                    updateProgress(jobId);
                    await new Promise(resolve => setTimeout(resolve, 60000));
                    i--;
                    continue;
                }
                
                // Other errors - skip this release and continue
                console.warn(`Skipping release ${releaseId} due to error:`, error.message);
                consecutiveErrors = 0; // Reset on non-rate-limit errors
            }
            
            // Reset error counter on successful fetch
            if (consecutiveErrors > 0) {
                consecutiveErrors = 0;
            }
        }
        
        seller.lastUpdated = Date.now();
        saveTrackedSellers();
        await saveSellerDataToDB(seller);
        updateSellerList();
        
        updateJob(jobId, {
            status: 'complete',
            currentStep: `Complete! Processed ${processedReleases.length} releases.`,
            progress: newReleaseIds.length
        });
        updateProgress(jobId);
        
        loadAllSellersData();
        finishJob(jobId, username);
        
    } catch (error) {
        console.error('Error processing releases:', error);
        updateJob(jobId, {
            status: 'error',
            currentStep: `Error: ${error.message}`
        });
        updateProgress(jobId);
        finishJob(jobId, username);
    }
}

async function resumeJob(jobId, username) {
    const job = getJobFromStorage(jobId);
    if (!job) return;
    
    // Resume processing releases from cached inventory
    updateProgress(jobId);
    
    await processReleasesFromInventory(jobId, username);
}

function updateProgress(jobId) {
    const job = getJobFromStorage(jobId);
    if (!job) return;
    
    // Update the seller's currentJob
    const username = job.username || job.seller_username;
    if (username) {
        const seller = trackedSellers.find(s => s.username === username);
        if (seller) {
            seller.currentJob = job;
            updateSellerList();
        }
    }
}

function isProcessingActive() {
    try {
        return Array.isArray(trackedSellers) && trackedSellers.some(s => s && s.currentJob && s.currentJob.status === 'processing');
    } catch (e) {
        return false;
    }
}

function cancelJob(jobId, event) {
    if (event) {
        event.stopPropagation();
    }
    
    if (!confirm('Are you sure you want to cancel this job?')) {
        return;
    }
    
    const job = updateJob(jobId, {
        status: 'cancelled',
        currentStep: 'Cancelled by user'
    });
    
    const username = job?.username || job?.seller_username;
    finishJob(jobId, username);
}

function finishJob(jobId, username) {
    const job = getJobFromStorage(jobId);
    const sellerUsername = username || job?.username || job?.seller_username;
    
    if (sellerUsername) {
        const seller = trackedSellers.find(s => s.username === sellerUsername);
        if (seller) {
            if (job && job.status === 'complete') {
                // Clear the job after a short delay
                setTimeout(() => {
                    seller.currentJob = null;
                    updateSellerList();
                }, 2000);
            } else if (job && job.status === 'cancelled') {
                // Keep cancelled status visible briefly
                seller.currentJob = job;
                updateSellerList();
                setTimeout(() => {
                    seller.currentJob = null;
                    updateSellerList();
                }, 2000);
            } else {
                seller.currentJob = null;
                updateSellerList();
            }
        }
    }
    
    localStorage.removeItem('currentJobId');
    localStorage.removeItem('currentUsername');
    localStorage.removeItem(`job_${jobId}`);
}

// ==================== DISPLAY & FILTERING ====================
let lastDataHash = '';

function displayResults(releases, isProcessing = false) {
    const currentHash = JSON.stringify(releases.map(r => r.id + '-' + r.artist_title));
    const hasNewData = currentHash !== lastDataHash;
    
    if (hasNewData || !isProcessing) {
        lastDataHash = currentHash;
        
        allData = releases.map(r => ({
            ...r,
            demand_coeff: computeRarityCoeff(r.have_count, r.want_count)
        }));
        
        if (!isProcessing) {
            populateFilterOptions(allData);
        }
        
        const savePage = isProcessing ? currentPage : 1;
        applyFilters(savePage);
    }
    
    if (isProcessing) {
        const resultsSection = document.getElementById('resultsSection');
        if (resultsSection) {
            const existingNote = document.getElementById('processingNote');
            if (!existingNote) {
                const note = document.createElement('div');
                note.id = 'processingNote';
                note.className = 'alert alert-info mt-2';
                note.innerHTML = '<i class="bi bi-hourglass-split"></i> Still processing... Results will update automatically.';
                resultsSection.insertBefore(note, resultsSection.firstChild);
            }
        }
    } else {
        const existingNote = document.getElementById('processingNote');
        if (existingNote) {
            existingNote.remove();
        }
        lastDataHash = '';
    }
}

function populateFilterOptions(releases) {
    const genreSelect = document.getElementById('genre');
    const styleSelect = document.getElementById('style');
    const artistSelect = document.getElementById('artist');
    const labelSelect = document.getElementById('label');
    
    const genreCounts = new Map();
    const styleCounts = new Map();
    const artistCounts = new Map();
    const labelCounts = new Map();
    
    releases.forEach(release => {
        if (release.genres) {
            try {
                const genres = JSON.parse(release.genres);
                genres.forEach(g => {
                    genreCounts.set(g, (genreCounts.get(g) || 0) + 1);
                });
            } catch (e) {}
        }
        
        if (release.styles) {
            try {
                const styles = JSON.parse(release.styles);
                styles.forEach(s => {
                    styleCounts.set(s, (styleCounts.get(s) || 0) + 1);
                });
            } catch (e) {}
        }
        
        if (release.artist) {
            const artists = release.artist.split(/[,&\/]/).map(a => a.trim()).filter(a => a);
            artists.forEach(a => {
                artistCounts.set(a, (artistCounts.get(a) || 0) + 1);
            });
        }
        
        if (release.label) {
            const labels = release.label.split(/[,&\/]/).map(l => l.trim()).filter(l => l);
            labels.forEach(l => {
                labelCounts.set(l, (labelCounts.get(l) || 0) + 1);
            });
        }
    });
    
    function populateSelect(select, counts, currentValue) {
        select.innerHTML = '';
        const allOption = document.createElement('option');
        allOption.value = '';
        allOption.textContent = select.id === 'genre' ? 'All Genres' : 
                              select.id === 'style' ? 'All Styles' :
                              select.id === 'artist' ? 'All Artists' : 'All Labels';
        select.appendChild(allOption);
        
        Array.from(counts.entries())
            .sort((a, b) => {
                if (b[1] !== a[1]) return b[1] - a[1];
                return a[0].localeCompare(b[0]);
            })
            .forEach(([value, count]) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = `${value} (${count})`;
                if (value === currentValue) option.selected = true;
                select.appendChild(option);
            });
    }
    
    populateSelect(genreSelect, genreCounts, genreSelect.value);
    populateSelect(styleSelect, styleCounts, styleSelect.value);
    populateSelect(artistSelect, artistCounts, artistSelect.value);
    populateSelect(labelSelect, labelCounts, labelSelect.value);
}

function applyFilters(preservePage = null) {
    // Read from navbar search; fallback to legacy input if present
    const q = ((document.getElementById('navSearchInput')?.value) || (document.getElementById('text_search')?.value) || '').toLowerCase().trim();
    const selectedGenre = document.getElementById('genre').value;
    const selectedStyle = document.getElementById('style').value;
    const selectedArtist = document.getElementById('artist').value;
    const selectedLabel = document.getElementById('label').value;
    const yearRange = document.getElementById('year_range').value;
    const ratingRange = document.getElementById('rating_range').value;
    const ratingCountRange = document.getElementById('rating_count_range').value;
    const priceRange = document.getElementById('price_range') ? document.getElementById('price_range').value : '';
    
    let minYear = 0, maxYear = 9999;
    if (yearRange && yearRange.includes('-')) {
        const parts = yearRange.split('-');
        minYear = parseInt(parts[0]) || 0;
        maxYear = parseInt(parts[1]) || 9999;
    }
    
    let minRating = 0, maxRating = 5;
    if (ratingRange && ratingRange.includes('-')) {
        const parts = ratingRange.split('-');
        minRating = parseFloat(parts[0]) || 0;
        maxRating = parseFloat(parts[1]) || 5;
    }
    
    let minRatingCount = 0, maxRatingCount = Infinity;
    if (ratingCountRange && ratingCountRange.includes('-')) {
        const parts = ratingCountRange.split('-');
        minRatingCount = parseInt(parts[0]) || 0;
        maxRatingCount = parseInt(parts[1]) || Infinity;
    }
    
    let minPrice = 0, maxPrice = Infinity;
    if (priceRange && priceRange.includes('-')) {
        const parts = priceRange.split('-');
        minPrice = parseFloat(parts[0]) || 0;
        maxPrice = parseFloat(parts[1]) || Infinity;
    }
    
    filteredData = allData.filter(release => {
        if (selectedSellers.length > 0 && !selectedSellers.includes(release.seller_username)) {
            return false;
        }
        if (q) {
            // Build a comprehensive haystack across common fields
            let genresStr = '';
            let stylesStr = '';
            try { if (release.genres) genresStr = JSON.parse(release.genres).join(' '); } catch (e) {}
            try { if (release.styles) stylesStr = JSON.parse(release.styles).join(' '); } catch (e) {}
            const hay = (
                (release.title || release.artist_title || '') + ' ' +
                (release.artist || '') + ' ' +
                (release.label || '') + ' ' +
                genresStr + ' ' + stylesStr + ' ' +
                (release.seller_username || '')
            ).toLowerCase();
            if (!hay.includes(q)) return false;
        }
        
        if (selectedGenre) {
            let genres = [];
            if (release.genres) {
                try {
                    genres = JSON.parse(release.genres);
                } catch (e) {}
            }
            if (!genres.includes(selectedGenre)) return false;
        }
        
        if (selectedStyle) {
            let styles = [];
            if (release.styles) {
                try {
                    styles = JSON.parse(release.styles);
                } catch (e) {}
            }
            if (!styles.includes(selectedStyle)) return false;
        }
        
        if (selectedArtist) {
            if (!release.artist) return false;
            const artists = release.artist.split(/[,&\/]/).map(a => a.trim());
            if (!artists.includes(selectedArtist)) return false;
        }
        
        if (selectedLabel) {
            if (!release.label) return false;
            const labels = release.label.split(/[,&\/]/).map(l => l.trim());
            if (!labels.includes(selectedLabel)) return false;
        }
        
        if (release.year && (release.year < minYear || release.year > maxYear)) {
            return false;
        }
        
        if (release.avg_rating < minRating || release.avg_rating > maxRating) {
            return false;
        }
        
        if (release.num_ratings < minRatingCount || release.num_ratings > maxRatingCount) {
            return false;
        }
        
        const priceVal = typeof release.price === 'number' ? release.price : parseFloat(release.price) || 0;
        if (priceVal < minPrice || priceVal > maxPrice) {
            return false;
        }
        
        return true;
    });
    
    sortData();
    
    totalRecords = filteredData.length;
    if (preservePage !== null) {
        currentPage = Math.min(preservePage, Math.ceil(totalRecords / pageSize)) || 1;
    } else {
        currentPage = 1;
    }
    totalPages = Math.ceil(totalRecords / pageSize);
    
    renderTable();
    renderPagination();
}

function sortData() {
    if (!currentSort.column) return;
    
    filteredData.sort((a, b) => {
        let aVal = a[currentSort.column];
        let bVal = b[currentSort.column];
        
        if (aVal === null || aVal === undefined) aVal = '';
        if (bVal === null || bVal === undefined) bVal = '';
        
        if (typeof aVal === 'number' && typeof bVal === 'number') {
            return currentSort.direction === 'asc' ? aVal - bVal : bVal - aVal;
        }
        
        aVal = String(aVal).toLowerCase();
        bVal = String(bVal).toLowerCase();
        
        if (currentSort.direction === 'asc') {
            return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
        } else {
            return bVal < aVal ? -1 : bVal > aVal ? 1 : 0;
        }
    });
}

function sortByColumn(column) {
    if (currentSort.column === column) {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        currentSort.column = column;
        currentSort.direction = 'desc';
    }
    
    applyFilters(currentPage);
    updateSortIndicators();
}

// ==================== TABLE RENDERING ====================
function renderTable() {
    const tbody = document.getElementById('releases-table-body');
    if (!tbody) return;
    
    setupTableHeaders();
    updateSortIndicators();
    
    if (filteredData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="15" class="text-center">No releases found</td></tr>';
        return;
    }
    
    // Ensure any placeholder/no-results rows are removed when we have data
    Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
        if (!tr.hasAttribute('data-release-id') || tr.querySelector('.no-results')) {
            tr.remove();
        }
    });

    const processingActive = isProcessingActive();
    const start = (currentPage - 1) * pageSize;
    const end = Math.min(start + pageSize, filteredData.length);
    const pageData = filteredData.slice(start, end);

    // Preserve existing rows to avoid reloading iframes
    const existingRows = new Map();
    tbody.querySelectorAll('tr[data-release-id]').forEach((row) => {
        const rid = row.getAttribute('data-release-id');
        if (rid) existingRows.set(rid, row);
    });

    if (!processingActive) {
        // Normal behavior: keep only rows for the current page and in correct order
        const currentPageIds = new Set(pageData.map(r => String(r.id)));
        existingRows.forEach((row, rid) => {
            if (!currentPageIds.has(rid)) {
                row.remove();
                existingRows.delete(rid);
            } else {
                row.style.display = '';
            }
        });
        // Append rows in order
        pageData.forEach((release) => {
            const idStr = String(release.id);
            let row = existingRows.get(idStr);
            if (!row) {
                row = document.createElement('tr');
                row.setAttribute('data-release-id', idStr);
                renderRow(row, release);
            } else {
                // Update existing row only if data has changed
                updateRowIfNeeded(row, release);
            }
            tbody.appendChild(row);
        });
    } else {
        // Processing: do not remove or reorder existing rows; just hide/show to reflect filters
        const currentPageIds = new Set(pageData.map(r => String(r.id)));
        existingRows.forEach((row, rid) => {
            if (currentPageIds.has(rid)) {
                row.style.display = '';
                // Update the row data if it changed, but preserve iframes
                const release = pageData.find(r => String(r.id) === rid);
                if (release) {
                    updateRowIfNeeded(row, release);
                }
            } else {
                row.style.display = 'none';
            }
        });
        // Create rows that are needed but not yet present (append at end)
        pageData.forEach((release) => {
            const idStr = String(release.id);
            if (!existingRows.has(idStr)) {
                const row = document.createElement('tr');
                row.setAttribute('data-release-id', idStr);
                renderRow(row, release);
                tbody.appendChild(row);
            }
        });
    }
    
    document.getElementById('resultsSection').style.display = 'block';
}

// Function to update a row only if data has changed, preserving iframes
function formatConditionAbbrev(raw) {
    if (!raw || typeof raw !== 'string') return '';
    const s = raw.trim();
    // Prefer abbreviation inside parentheses if available
    const paren = s.match(/\(([^)]+)\)/);
    if (paren && /\b(M|NM|VG\+?|G\+?|F|P)\b/i.test(paren[1])) {
        const token = paren[1].match(/(M|NM|VG\+?|G\+?|F|P)/i)[1].toUpperCase();
        // Normalize M- to NM
        return token === 'M-' ? 'NM' : token;
    }
    // Map common verbose strings
    const map = [
        [/^(mint)\b/i, 'M'],
        [/(near\s*mint|nm|m-)\b/i, 'NM'],
        [/vg\s*\+|very\s*good\s*\+/i, 'VG+'],
        [/\bvg\b|very\s*good(?!\s*\+)/i, 'VG'],
        [/g\s*\+|good\s*\+/i, 'G+'],
        [/\bg\b|\bgood\b/i, 'G'],
        [/\bfair\b|\bf\b/i, 'F'],
        [/\bpoor\b|\bp\b/i, 'P']
    ];
    for (const [re, abbr] of map) {
        if (re.test(s)) return abbr;
    }
    return s.toUpperCase();
}

function getReleaseCondition(release) {
    const direct = (
        release?.media_condition ||
        release?.condition ||
        release?.item_condition ||
        release?.condition_grade ||
        ''
    );
    if (direct && typeof direct === 'string') return direct;
    // Fallback: find any property containing 'condition'
    try {
        for (const key of Object.keys(release || {})) {
            if (key.toLowerCase().includes('condition')) {
                const val = release[key];
                if (typeof val === 'string' && val.trim()) {
                    return val;
                }
            }
        }
    } catch (e) {}
    return '';
}

function formatPrice(value) {
    if (value == null) return '-';
    // If release.price is a number
    if (typeof value === 'number') {
        return '$' + value.toFixed(2);
    }
    // If object with value/currency
    if (typeof value === 'object') {
        if (typeof value.formatted === 'string' && value.formatted.trim()) {
            return value.formatted;
        }
        if (typeof value.value === 'number') {
            const curr = value.currency || value.curr_abbr || '';
            if (curr) return `${curr === 'EUR' ? '‚Ç¨' : curr === 'USD' ? '$' : curr} ${value.value.toFixed(2)}`;
            return value.value.toFixed(2);
        }
    }
    // Fallback: string
    if (typeof value === 'string' && value.trim()) return value;
    return '-';
}

function updateRowIfNeeded(row, release) {
    // Store the release data as a JSON string for comparison
    const newDataHash = JSON.stringify({
        title: release.title,
        artist: release.artist,
        label: release.label,
        year: release.year,
        genres: release.genres,
        styles: release.styles,
        avg_rating: release.avg_rating,
        num_ratings: release.num_ratings,
        seller_username: release.seller_username,
        demand_coeff: release.demand_coeff,
        have_count: release.have_count,
        want_count: release.want_count,
        price: release.price,
        video_urls: release.video_urls,
        media_condition: release.media_condition,
        condition: release.condition,
        item_condition: release.item_condition,
        condition_grade: release.condition_grade
    });
    
    const oldDataHash = row.getAttribute('data-release-hash');
    
    // If data hasn't changed, skip update
    if (oldDataHash === newDataHash) {
        return;
    }
    
    // Store the new hash
    row.setAttribute('data-release-hash', newDataHash);
    
    const isMobile = window.innerWidth <= 768;
    
    if (isMobile) {
        // For mobile, we need to update the entire cell content except for the iframe
        // Get existing iframe if it exists
        const existingIframe = row.querySelector('iframe');
        const existingPreview = row.querySelector('.mobile-preview');
        
        // Re-render the row
        row.innerHTML = '';
        renderRow(row, release);
        
        // If there was an iframe and it's the same video, restore it to avoid reload
        if (existingIframe && existingPreview) {
            const newPreview = row.querySelector('.mobile-preview');
            if (newPreview && newPreview.querySelector('iframe')) {
                const newIframe = newPreview.querySelector('iframe');
                // Compare src without query parameters
                const oldSrc = existingIframe.src.split('?')[0];
                const newSrc = newIframe.src.split('?')[0];
                if (oldSrc === newSrc) {
                    // Same video, restore the old iframe to preserve state
                    newIframe.replaceWith(existingIframe);
                }
            }
        }
    } else {
        // For desktop, update individual cells without touching the video cell
        const cells = row.querySelectorAll('td');
        
        let genres = [];
        let styles = [];
        try {
            if (release.genres) genres = JSON.parse(release.genres);
            if (release.styles) styles = JSON.parse(release.styles);
        } catch (e) {}
        
        // Update cells by index (based on desktop column order)
        // 0: Title only (badge removed)
        if (cells[0]) {
            cells[0].innerHTML = `
                <div class="title-cell">
                    <a href="${release.url}" target="_blank" class="release-link">${escapeHtml(release.title || release.artist_title)}</a>
                </div>
            `;
        }
        // 1: Artist
        if (cells[1]) {
            cells[1].textContent = release.artist || '-';
        }
        // 2: Label
        if (cells[2]) {
            cells[2].textContent = release.label || '-';
        }
        // 3: Year
        if (cells[3]) {
            cells[3].textContent = release.year || '-';
        }
        // 4: Genre/Style
        if (cells[4]) {
            cells[4].innerHTML = '';
            if (genres.length > 0) {
                genres.forEach(g => {
                    const span = document.createElement('span');
                    span.className = 'badge-genre';
                    span.textContent = g;
                    cells[4].appendChild(span);
                });
            }
            if (styles.length > 0) {
                styles.forEach(s => {
                    const span = document.createElement('span');
                    span.className = 'badge-style';
                    span.textContent = s;
                    cells[4].appendChild(span);
                });
            }
            if (genres.length === 0 && styles.length === 0) {
                cells[4].textContent = '-';
            }
        }
        // 5: Rating
        if (cells[5]) {
            const ratingStars = release.avg_rating ? generateStars(release.avg_rating) : '<div class="text-muted">No rating</div>';
            const ratingText = release.avg_rating ? `${parseFloat(release.avg_rating).toFixed(2)}${release.num_ratings ? ` (${release.num_ratings})` : ''}` : '';
            cells[5].innerHTML = `${ratingStars} ${ratingText}`;
        }
        // 6: Seller
        if (cells[6]) {
            cells[6].innerHTML = `<span class="badge bg-secondary">${escapeHtml(release.seller_username || '')}</span>`;
        }
        // 7: Rarity
        if (cells[7]) {
            cells[7].textContent = release.demand_coeff ? parseFloat(release.demand_coeff).toFixed(2) : '-';
        }
        // 8: # Ratings
        if (cells[8]) {
            cells[8].textContent = release.num_ratings || '0';
        }
        // 9: Have
        if (cells[9]) {
            cells[9].textContent = release.have_count || '0';
        }
        // 10: Want
        if (cells[10]) {
            cells[10].textContent = release.want_count || '0';
        }
        // 11: Price with condition badge
        if (cells[11]) {
            const priceConditionAbbr = formatConditionAbbrev(getReleaseCondition(release));
            const priceText = formatPrice(release.price);
            cells[11].innerHTML = `
                <div class="price-cell" style="display:inline-block; position:relative; min-width: 64px;">
                    <span class="price-text">${priceText}</span>
                    ${priceConditionAbbr ? `<span class=\"badge-condition\">${priceConditionAbbr}</span>` : ''}
                </div>
            `;
        }
        // 12: Video - only update if video URLs have changed
        if (cells[12]) {
            const existingCarousel = cells[12].querySelector('.video-carousel');
            const existingIframe = existingCarousel ? existingCarousel.querySelector('iframe') : null;
            
            let rawVideoLinks = [];
            if (release.video_urls) {
                try {
                    rawVideoLinks = JSON.parse(release.video_urls);
                } catch (e) {}
            }
            const videoLinks = sanitizeVideoLinks(rawVideoLinks);
            
            // Check if video URLs are the same
            let shouldUpdateVideo = true;
            if (existingCarousel) {
                const carouselVideosAttr = existingCarousel.querySelector('.video-nav-btn')?.getAttribute('data-videos');
                if (carouselVideosAttr) {
                    try {
                        const existingVideos = JSON.parse(decodeURIComponent(carouselVideosAttr));
                        if (JSON.stringify(existingVideos) === JSON.stringify(videoLinks)) {
                            shouldUpdateVideo = false;
                        }
                    } catch (e) {}
                }
            }
            
            // Only update video cell if videos have changed
            if (shouldUpdateVideo) {
                let videoCell = '';
                if (videoLinks.length > 0) {
                    const firstVideo = videoLinks[0];
                    const firstVideoId = extractYouTubeID(firstVideo.url);
                    
                    if (firstVideoId) {
                        const videosDataAttr = encodeURIComponent(JSON.stringify(videoLinks));
                        videoCell = `
                            <div class="video-carousel" id="carousel-${release.id}" data-release-id="${release.id}">
                                <iframe id="youtube-player-${release.id}" class="table-iframe" loading="lazy" 
                                    title="YouTube video player" aria-label="YouTube video player" 
                                    src="https://www.youtube.com/embed/${firstVideoId}?enablejsapi=1&rel=0&modestbranding=1" 
                                    frameborder="0" 
                                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                                    allowfullscreen 
                                    style="width: 220px; height: 124px;">
                                </iframe>
                        `;
                        
                        if (videoLinks.length > 1) {
                            videoCell += `
                                <div class="video-nav d-flex justify-content-between align-items-center mt-1">
                                    <button class="btn btn-sm btn-outline-secondary video-nav-btn" data-release-id="${release.id}" data-direction="-1" data-videos="${videosDataAttr}">
                                        <i class="bi bi-chevron-left"></i>
                                    </button>
                                    <span class="video-counter" id="counter-${release.id}">1 / ${videoLinks.length}</span>
                                    <button class="btn btn-sm btn-outline-secondary video-nav-btn" data-release-id="${release.id}" data-direction="1" data-videos="${videosDataAttr}">
                                        <i class="bi bi-chevron-right"></i>
                                    </button>
                                </div>
                            `;
                        }
                        videoCell += '</div>';
                    } else {
                        const linksToShow = videoLinks.slice(0, 3);
                        if (linksToShow.length > 0) {
                            videoCell = '<div class="video-links">';
                            linksToShow.forEach((video, idx) => {
                                videoCell += `<a href="${escapeHtml(video.url)}" target="_blank" class="btn btn-sm btn-outline-primary mb-1" style="display: block; font-size: 0.75rem;">
                                    <i class="bi bi-play-circle"></i> ${escapeHtml(video.title || 'Video ' + (idx + 1))}
                                </a>`;
                            });
                            videoCell += '</div>';
                        }
                    }
                }
                
                if (!videoCell) {
                    videoCell = `
                        <a href="https://www.youtube.com/results?search_query=${encodeURIComponent((release.artist || '') + ' ' + (release.title || release.artist_title || ''))}" 
                           target="_blank" class="btn btn-sm btn-outline-secondary">
                            <i class="bi bi-search"></i> Search
                        </a>
                    `;
                }
                
                cells[12].innerHTML = videoCell;
            }
        }
    }
}

function renderRow(row, release) {
    // Store the release data hash for future comparisons
    const dataHash = JSON.stringify({
        title: release.title,
        artist: release.artist,
        label: release.label,
        year: release.year,
        genres: release.genres,
        styles: release.styles,
        avg_rating: release.avg_rating,
        num_ratings: release.num_ratings,
        seller_username: release.seller_username,
        demand_coeff: release.demand_coeff,
        have_count: release.have_count,
        want_count: release.want_count,
        price: release.price,
        video_urls: release.video_urls
    });
    row.setAttribute('data-release-hash', dataHash);
    
    const isMobile = window.innerWidth <= 768;
    
    let genres = [];
    let styles = [];
    try {
        if (release.genres) genres = JSON.parse(release.genres);
        if (release.styles) styles = JSON.parse(release.styles);
    } catch (e) {}
    
    // Video cell
    let videoCell = '';
    let rawVideoLinks = [];
    
    if (release.video_urls) {
        try {
            rawVideoLinks = JSON.parse(release.video_urls);
        } catch (e) {}
    }
    
    const videoLinks = sanitizeVideoLinks(rawVideoLinks);
    
    if (isMobile) {
        // Mobile layout: single cell with all content
        let previewContent = '';
        if (videoLinks.length > 0) {
            const firstVideo = videoLinks[0];
            const firstVideoId = extractYouTubeID(firstVideo.url);
            if (firstVideoId) {
                previewContent = `<div class="mobile-preview">
                    <iframe id="youtube-player-${release.id}" loading="lazy" 
                        title="YouTube video player" aria-label="YouTube video player" 
                        src="https://www.youtube.com/embed/${firstVideoId}?enablejsapi=1&rel=0&modestbranding=1" 
                        frameborder="0" 
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                        allowfullscreen
                        style="width: 100%; height: auto; aspect-ratio: 16 / 9;"></iframe>
                </div>`;
            } else {
                previewContent = '<div class="mobile-preview text-muted">Invalid YouTube link</div>';
            }
        } else {
            previewContent = '<div class="mobile-preview text-muted">No YouTube links</div>';
        }
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'mobile-title';
        const titleLink = document.createElement('a');
        titleLink.href = release.url;
        titleLink.target = '_blank';
        titleLink.className = 'release-link';
        titleLink.textContent = release.title || release.artist_title;
        titleDiv.appendChild(titleLink);
        
        const ratingDiv = document.createElement('div');
        ratingDiv.className = 'mobile-rating';
        if (release.avg_rating) {
            ratingDiv.innerHTML = `${generateStars(release.avg_rating)} ${parseFloat(release.avg_rating).toFixed(2)}${release.num_ratings ? ` (${release.num_ratings})` : ''}`;
        } else {
            ratingDiv.innerHTML = '<div class="text-muted">No rating</div>';
        }
        
        // Additional info
        const infoDiv = document.createElement('div');
        infoDiv.style.fontSize = '12px';
        infoDiv.style.opacity = '0.8';
        infoDiv.style.marginTop = '8px';
        let infoText = [];
        if (release.artist) infoText.push(`Artist: ${release.artist}`);
        if (release.label) infoText.push(`Label: ${release.label}`);
        if (release.year) infoText.push(`Year: ${release.year}`);
        if (release.price) infoText.push(`Price: $${release.price.toFixed(2)}`);
        if (release.seller_username) infoText.push(`Seller: ${release.seller_username}`);
        infoDiv.textContent = infoText.join(' ‚Ä¢ ');
        
        const tdMobile = document.createElement('td');
        tdMobile.className = 'mobile-cell';
        tdMobile.innerHTML = previewContent;
        tdMobile.appendChild(titleDiv);
        tdMobile.appendChild(ratingDiv);
        tdMobile.appendChild(infoDiv);
        
        // Add genre/style badges if available
        if (genres.length > 0 || styles.length > 0) {
            const badgesDiv = document.createElement('div');
            badgesDiv.style.marginTop = '8px';
            genres.forEach(g => {
                const span = document.createElement('span');
                span.className = 'badge-genre';
                span.textContent = g;
                badgesDiv.appendChild(span);
            });
            styles.forEach(s => {
                const span = document.createElement('span');
                span.className = 'badge-style';
                span.textContent = s;
                badgesDiv.appendChild(span);
            });
            tdMobile.appendChild(badgesDiv);
        }
        
        row.appendChild(tdMobile);
    } else {
        // Desktop layout: multiple columns
        const genreStyleCell = document.createElement('td');
        if (genres.length > 0) {
            genres.forEach(g => {
                const span = document.createElement('span');
                span.className = 'badge-genre';
                span.textContent = g;
                genreStyleCell.appendChild(span);
            });
        }
        if (styles.length > 0) {
            styles.forEach(s => {
                const span = document.createElement('span');
                span.className = 'badge-style';
                span.textContent = s;
                genreStyleCell.appendChild(span);
            });
        }
        if (genres.length === 0 && styles.length === 0) {
            genreStyleCell.textContent = '-';
        }
        
        if (videoLinks.length > 0) {
            const firstVideo = videoLinks[0];
            const firstVideoId = extractYouTubeID(firstVideo.url);
            
            if (firstVideoId) {
                const videosDataAttr = encodeURIComponent(JSON.stringify(videoLinks));
                videoCell = `
                    <div class="video-carousel" id="carousel-${release.id}" data-release-id="${release.id}">
                        <iframe id="youtube-player-${release.id}" class="table-iframe" loading="lazy" 
                            title="YouTube video player" aria-label="YouTube video player" 
                            src="https://www.youtube.com/embed/${firstVideoId}?enablejsapi=1&rel=0&modestbranding=1" 
                            frameborder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            allowfullscreen 
                            style="width: 220px; height: 124px;">
                        </iframe>
                `;
                
                if (videoLinks.length > 1) {
                    videoCell += `
                        <div class="video-nav d-flex justify-content-between align-items-center mt-1">
                            <button class="btn btn-sm btn-outline-secondary video-nav-btn" data-release-id="${release.id}" data-direction="-1" data-videos="${videosDataAttr}">
                                <i class="bi bi-chevron-left"></i>
                            </button>
                            <span class="video-counter" id="counter-${release.id}">1 / ${videoLinks.length}</span>
                            <button class="btn btn-sm btn-outline-secondary video-nav-btn" data-release-id="${release.id}" data-direction="1" data-videos="${videosDataAttr}">
                                <i class="bi bi-chevron-right"></i>
                            </button>
                        </div>
                    `;
                }
                videoCell += '</div>';
            } else {
                const linksToShow = videoLinks.slice(0, 3);
                if (linksToShow.length > 0) {
                    videoCell = '<div class="video-links">';
                    linksToShow.forEach((video, idx) => {
                        videoCell += `<a href="${escapeHtml(video.url)}" target="_blank" class="btn btn-sm btn-outline-primary mb-1" style="display: block; font-size: 0.75rem;">
                            <i class="bi bi-play-circle"></i> ${escapeHtml(video.title || 'Video ' + (idx + 1))}
                        </a>`;
                    });
                    videoCell += '</div>';
                }
            }
        }
        
        if (!videoCell) {
            videoCell = `
                <a href="https://www.youtube.com/results?search_query=${encodeURIComponent((release.artist || '') + ' ' + (release.title || release.artist_title || ''))}" 
                   target="_blank" class="btn btn-sm btn-outline-secondary">
                    <i class="bi bi-search"></i> Search
                </a>
            `;
        }
        
        const ratingStars = release.avg_rating ? generateStars(release.avg_rating) : '<div class="text-muted">No rating</div>';
        const ratingText = release.avg_rating ? `${parseFloat(release.avg_rating).toFixed(2)}${release.num_ratings ? ` (${release.num_ratings})` : ''}` : '';
        
        // Basic columns always shown
        row.innerHTML = `
            <td>
                <div class="title-cell">
                    <a href="${release.url}" target="_blank" class="release-link">${escapeHtml(release.title || release.artist_title)}</a>
                </div>
            </td>
            <td>${escapeHtml(release.artist || '-')}</td>
            <td>${escapeHtml(release.label || '-')}</td>
            <td class="text-center">${release.year || '-'}</td>
        `;
        row.appendChild(genreStyleCell);
        
        // Rating and community stats columns (shown in all views)
        row.innerHTML += `<td class="text-center">${ratingStars} ${ratingText}</td>`;
        
        // Seller column only for sellers view
        if (currentView === 'sellers') {
            row.innerHTML += `<td class="text-center"><span class="badge bg-secondary">${escapeHtml(release.seller_username || '')}</span></td>`;
        }
        
        // Community stats (shown in all views)
        row.innerHTML += `
            <td class="text-center">${release.demand_coeff ? parseFloat(release.demand_coeff).toFixed(2) : '-'}</td>
            <td class="text-center">${release.num_ratings || '0'}</td>
            <td class="text-center">${release.have_count || '0'}</td>
            <td class="text-center">${release.want_count || '0'}</td>
        `;
        
        // Price column only for sellers view
        if (currentView === 'sellers') {
            const priceConditionAbbr = formatConditionAbbrev(getReleaseCondition(release));
            row.innerHTML += `
                <td class="text-center"><div class="price-cell" style="display:inline-block; position:relative; min-width: 64px;">
                    <span class="price-text">${formatPrice(release.price)}</span>
                    ${priceConditionAbbr ? `<span class="badge-condition">${priceConditionAbbr}</span>` : ''}
                </div></td>
            `;
        }
        
        // Actions column for sellers and wantlist views (before videos)
        if (currentView === 'sellers' || currentView === 'wantlist') {
            const heartIcon = release.inWantlist 
                ? '<i class="bi bi-heart-fill" style="color: var(--accent-color);"></i>'
                : '<i class="bi bi-heart" style="color: #fff;"></i>';
            const titleText = release.inWantlist ? 'Remove from Wantlist' : 'Add to Wantlist';
            
            row.innerHTML += `
                <td class="text-center">
                    <button class="wantlist-heart-btn" onclick="toggleWantlist(${release.id}, this)" title="${titleText}">
                        ${heartIcon}
                    </button>
                </td>
            `;
        }
        
        // Video column always shown (after actions)
        row.innerHTML += `<td class="text-center">${videoCell}</td>`;
    }
}

function setupTableHeaders() {
    const thead = document.getElementById('table-header');
    thead.innerHTML = ''; // Clear existing headers
    
    // Define which columns to show based on current view
    let columns;
    if (currentView === 'collection') {
        // Collection columns (no seller, no price, no actions)
        columns = [
            { key: 'title', label: 'Title' },
            { key: 'artist', label: 'Artist' },
            { key: 'label', label: 'Label' },
            { key: 'year', label: 'Year' },
            { key: null, label: 'Genre / Style', nosort: true },
            { key: 'bayesian_score', label: 'Rating' },
            { key: 'demand_coeff', label: 'Rarity' },
            { key: 'num_ratings', label: '# Ratings' },
            { key: 'have_count', label: 'Have' },
            { key: 'want_count', label: 'Want' },
            { key: null, label: 'Videos', nosort: true }
        ];
    } else if (currentView === 'wantlist') {
        // Wantlist columns (show actions to remove)
        columns = [
            { key: 'title', label: 'Title' },
            { key: 'artist', label: 'Artist' },
            { key: 'label', label: 'Label' },
            { key: 'year', label: 'Year' },
            { key: null, label: 'Genre / Style', nosort: true },
            { key: 'bayesian_score', label: 'Rating' },
            { key: 'demand_coeff', label: 'Rarity' },
            { key: 'num_ratings', label: '# Ratings' },
            { key: 'have_count', label: 'Have' },
            { key: 'want_count', label: 'Want' },
            { key: null, label: 'Actions', nosort: true },
            { key: null, label: 'Videos', nosort: true }
        ];
    } else {
        // Full columns for seller tracking view
        columns = [
            { key: 'title', label: 'Title' },
            { key: 'artist', label: 'Artist' },
            { key: 'label', label: 'Label' },
            { key: 'year', label: 'Year' },
            { key: null, label: 'Genre / Style', nosort: true },
            { key: 'bayesian_score', label: 'Rating' },
            { key: 'seller_username', label: 'Seller' },
            { key: 'demand_coeff', label: 'Rarity' },
            { key: 'num_ratings', label: '# Ratings' },
            { key: 'have_count', label: 'Have' },
            { key: 'want_count', label: 'Want' },
            { key: 'price', label: 'Price' },
            { key: null, label: 'Actions', nosort: true },
            { key: null, label: 'Videos', nosort: true }
        ];
    }
    
    const headerRow = document.createElement('tr');
    columns.forEach(col => {
        const th = document.createElement('th');
        th.setAttribute('data-column-name', col.label);
        
        if (col.key && !col.nosort) {
            th.setAttribute('data-sort-key', col.key);
            th.style.cursor = 'pointer';
            th.addEventListener('click', () => sortByColumn(col.key));
            th.innerHTML = col.label;
        } else {
            th.textContent = col.label;
        }
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
}

function updateSortIndicators() {
    const thead = document.getElementById('table-header');
    if (!thead) return;
    
    const ths = thead.querySelectorAll('th[data-sort-key]');
    ths.forEach(th => {
        const sortKey = th.getAttribute('data-sort-key');
        const colName = th.getAttribute('data-column-name');
        
        th.innerHTML = colName;
        
        if (sortKey && currentSort.column === sortKey) {
            const icon = currentSort.direction === 'asc' 
                ? '<i class="bi bi-arrow-up sort-indicator"></i>'
                : '<i class="bi bi-arrow-down sort-indicator"></i>';
            th.innerHTML += icon;
        }
    });
}

function generateStars(avg) {
    const average = parseFloat(avg) || 0;
    const full = Math.floor(average);
    const half = average % 1 >= 0.5 ? 1 : 0;
    const empty = 5 - full - half;
    let html = '';
    for (let i = 0; i < full; i++) html += '<i class="bi bi-star-fill text-warning"></i>';
    if (half) html += '<i class="bi bi-star-half text-warning"></i>';
    for (let i = 0; i < empty; i++) html += '<i class="bi bi-star text-warning"></i>';
    return html;
}

// ==================== PAGINATION ====================
function renderPagination() {
    const pagination = document.getElementById('pagination');
    pagination.innerHTML = '';
    
    if (totalPages <= 1) {
        pagination.style.display = 'none';
        return;
    }
    
    pagination.style.display = 'flex';
    
    const prevLi = document.createElement('li');
    prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
    prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage - 1}); return false;">Previous</a>`;
    pagination.appendChild(prevLi);
    
    const maxButtons = 5;
    let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
    let endPage = Math.min(totalPages, startPage + maxButtons - 1);
    
    if (endPage - startPage < maxButtons - 1) {
        startPage = Math.max(1, endPage - maxButtons + 1);
    }
    
    for (let i = startPage; i <= endPage; i++) {
        const pageLi = document.createElement('li');
        pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
        pageLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${i}); return false;">${i}</a>`;
        pagination.appendChild(pageLi);
    }
    
    const nextLi = document.createElement('li');
    nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
    nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage + 1}); return false;">Next</a>`;
    pagination.appendChild(nextLi);
}

function stopAllVideos() {
    // Stop all YouTube videos by sending stop command to all iframes
    const youtubeIframes = document.querySelectorAll('iframe[src*="youtube.com/embed"]');
    youtubeIframes.forEach(iframe => {
        try {
            // Send stop command via postMessage to YouTube iframe
            // YouTube iframes with enablejsapi=1 accept commands via postMessage
            iframe.contentWindow.postMessage('{"event":"command","func":"stopVideo","args":""}', 'https://www.youtube.com');
        } catch (e) {
            // If postMessage fails, try alternative approach
            try {
                // Try pausing by setting src to empty and restoring (forces reload)
                const currentSrc = iframe.src;
                if (currentSrc.includes('youtube.com/embed')) {
                    // Reload the iframe to stop playback
                    iframe.src = currentSrc.split('&autoplay=1').join('').split('?autoplay=1').join('?');
                }
            } catch (e2) {
                console.warn('Error stopping YouTube video:', e2);
            }
        }
    });
    
    // Also stop any YouTube player instances if they exist
    if (youtubePlayerInstances && typeof youtubePlayerInstances === 'object') {
        Object.values(youtubePlayerInstances).forEach(player => {
            try {
                if (player && typeof player.stopVideo === 'function') {
                    player.stopVideo();
                }
            } catch (e) {
                console.warn('Error stopping YouTube player:', e);
            }
        });
    }
}

function changePage(page) {
    if (page < 1 || page > totalPages) return;
    // Stop all video playback before changing page
    stopAllVideos();
    currentPage = page;
    renderTable();
    renderPagination();
}

// ==================== VIDEO CAROUSEL ====================
document.addEventListener('click', function(e) {
    if (e.target.closest('.video-nav-btn')) {
        const btn = e.target.closest('.video-nav-btn');
        const releaseId = parseInt(btn.getAttribute('data-release-id'), 10);
        const direction = parseInt(btn.getAttribute('data-direction'), 10);
        const videosJson = btn.getAttribute('data-videos');
        
        if (!Number.isInteger(releaseId) || !Number.isInteger(direction) || !videosJson) {
            return;
        }

        try {
            const videos = JSON.parse(decodeURIComponent(videosJson));
            changeVideo(releaseId, direction, videos);
        } catch (err) {
            console.error('Error parsing videos JSON:', err);
        }
    }
});

function changeVideo(releaseId, direction, videos) {
    if (!Array.isArray(videos) || videos.length === 0) {
        return;
    }

    if (!currentVideoIndex[releaseId]) {
        currentVideoIndex[releaseId] = 0;
    }
    
    currentVideoIndex[releaseId] += direction;
    if (currentVideoIndex[releaseId] < 0) {
        currentVideoIndex[releaseId] = videos.length - 1;
    } else if (currentVideoIndex[releaseId] >= videos.length) {
        currentVideoIndex[releaseId] = 0;
    }
    
    const currentIndex = currentVideoIndex[releaseId];
    const video = videos[currentIndex];
    const videoUrl = getVideoUrl(video);
    const videoId = extractYouTubeID(videoUrl);
    
    if (videoId) {
        const iframe = document.getElementById(`youtube-player-${releaseId}`);
        if (iframe) {
            iframe.src = `https://www.youtube.com/embed/${videoId}?enablejsapi=1&rel=0&modestbranding=1`;
        }
    }
    
    const counter = document.getElementById(`counter-${releaseId}`);
    if (counter) {
        counter.textContent = `${currentIndex + 1} / ${videos.length}`;
    }
}
    </script>
</body>
</html>
